<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trench Bucket Scanner</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #00d9ff;
        }
        .mode-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
        }
        .mode-tab {
            padding: 12px 30px;
            border: none;
            border-radius: 5px 5px 0 0;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            background: #16213e;
            color: #888;
            transition: all 0.3s;
        }
        .mode-tab.active {
            background: #00d9ff;
            color: #1a1a2e;
        }
        .mode-tab:hover:not(.active) {
            background: #1f2b47;
            color: #eee;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        .btn-primary {
            background: #00d9ff;
            color: #1a1a2e;
        }
        .btn-primary:hover {
            background: #00b8d9;
        }
        .btn-success {
            background: #00ff88;
            color: #1a1a2e;
        }
        .btn-success:hover {
            background: #00cc6a;
        }
        .btn-warning {
            background: #ffaa00;
            color: #1a1a2e;
        }
        .btn-warning:hover {
            background: #dd9500;
        }
        .btn-danger {
            background: #ff4444;
            color: white;
        }
        .btn-danger:hover {
            background: #cc3333;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background: #5a6268;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #fileInput {
            display: none;
        }
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .image-card {
            background: #16213e;
            border-radius: 10px;
            padding: 15px;
            position: relative;
        }
        .image-card.selected {
            border: 3px solid #00d9ff;
        }
        .image-card h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #00d9ff;
            word-break: break-all;
        }
        .canvas-container {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        .canvas-container canvas {
            max-width: 100%;
            height: auto;
            cursor: crosshair;
            border-radius: 5px;
        }
        .coord-info {
            margin-top: 10px;
            font-size: 12px;
            color: #aaa;
        }
        .coord-info span {
            color: #00ff88;
        }
        .status-bar {
            background: #16213e;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .status-bar p {
            margin: 5px 0;
        }
        .settings-panel {
            background: #16213e;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .settings-panel h3 {
            margin-bottom: 15px;
            color: #00d9ff;
        }
        .settings-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .settings-section h4 {
            color: #ffaa00;
            margin-bottom: 10px;
            font-size: 14px;
        }
        .setting-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .setting-row label {
            min-width: 150px;
        }
        .setting-row input, .setting-row select {
            padding: 5px 10px;
            border: 1px solid #333;
            border-radius: 5px;
            background: #1a1a2e;
            color: #eee;
            width: 150px;
        }
        .setting-row select {
            width: 180px;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            transition: width 0.3s;
        }
        .help-text {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        .measurement-preview {
            margin-top: 10px;
            padding: 10px;
            background: #1a1a2e;
            border-radius: 5px;
            font-size: 11px;
        }
        .info-badge {
            display: inline-block;
            margin-left: 10px;
            padding: 2px 8px;
            background: #333;
            border-radius: 3px;
            font-size: 11px;
        }
        .model-status {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .model-indicator {
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 12px;
            background: #333;
        }
        .model-indicator.ready {
            background: #00ff8833;
            color: #00ff88;
        }
        .model-indicator.not-ready {
            background: #ff444433;
            color: #ff4444;
        }
        .model-source-info {
            margin-top: 10px;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 13px;
            font-weight: bold;
        }
        .model-source-info.none {
            background: #33333366;
            color: #888;
        }
        .model-source-info.built {
            background: #00ff8833;
            color: #00ff88;
        }
        .model-source-info.loaded {
            background: #00d9ff33;
            color: #00d9ff;
        }
        .subsettings {
            margin-left: 20px;
            padding: 10px;
            background: #1a1a2e;
            border-radius: 5px;
            margin-top: 10px;
        }
        .hidden {
            display: none !important;
        }
        .comparison-view {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .comparison-item {
            text-align: center;
            padding: 10px;
            background: #1a1a2e;
            border-radius: 5px;
        }
        .comparison-item h5 {
            color: #00d9ff;
            margin-bottom: 5px;
            font-size: 12px;
        }
        /* Mask overlay styles */
        .canvas-container {
            position: relative;
        }
        .mask-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            opacity: 0.5;
        }
        .mask-canvas.editing {
            pointer-events: auto;
            cursor: crosshair;
        }
        .mask-controls {
            display: flex;
            gap: 5px;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        .mask-controls button {
            padding: 4px 8px;
            font-size: 11px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .mask-controls button.active {
            box-shadow: 0 0 5px #00d9ff;
        }
        .mask-btn-auto { background: #00d9ff; color: #1a1a2e; }
        .mask-btn-draw { background: #00ff88; color: #1a1a2e; }
        .mask-btn-erase { background: #ffaa00; color: #1a1a2e; }
        .mask-btn-clear { background: #ff4444; color: white; }
        .mask-btn-apply { background: #9933ff; color: white; }
        .mask-status {
            font-size: 10px;
            color: #888;
            margin-top: 5px;
        }
        .mask-status.active {
            color: #00ff88;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Trench Bucket Scanner</h1>

        <!-- Main Algorithm Selector -->
        <div class="algorithm-selector" style="margin-bottom: 15px; padding: 15px; background: #16213e; border-radius: 8px; border: 1px solid #00d9ff;">
            <div style="display: flex; align-items: center; gap: 15px;">
                <label style="font-weight: bold; color: #00d9ff;">Algorithm:</label>
                <select id="mainAlgorithm" onchange="updateAlgorithmUI()" style="padding: 8px 12px; font-size: 14px; border-radius: 5px; background: #1a1a2e; color: white; border: 1px solid #444; min-width: 200px;">
                    <optgroup label="Edge Detection (No Training)">
                        <option value="ray">Ray (Threshold)</option>
                        <option value="canny">Canny Edge</option>
                        <option value="adaptive">Adaptive Threshold</option>
                        <option value="sobel">Sobel Gradient</option>
                    </optgroup>
                    <optgroup label="Shape Learning (Training Required)">
                        <option value="statistical">Statistical Model</option>
                        <option value="template">Template Matching</option>
                        <option value="neural">Neural Network</option>
                    </optgroup>
                </select>
                <span id="algorithmDescription" style="color: #888; font-size: 12px;">이미지 처리만으로 boundary 추출 (Training 불필요)</span>
            </div>
        </div>

        <div class="mode-tabs" id="modeTabs">
            <button class="mode-tab active" onclick="switchMode('training')" id="tabTraining">Training Mode</button>
            <button class="mode-tab" onclick="switchMode('detection')" id="tabDetection">Detection Mode</button>
        </div>

        <div class="status-bar">
            <p><strong>Status:</strong> <span id="statusText">Ready - Load training images to begin</span></p>
            <p><strong>Images:</strong> <span id="imageCount">0</span> |
               <strong>With Points:</strong> <span id="pointCount">0</span> |
               <strong>Boundaries Extracted:</strong> <span id="boundaryCount">0</span></p>
            <div class="model-status">
                <span class="model-indicator not-ready" id="statModelStatus">Statistical: Not Ready</span>
                <span class="model-indicator not-ready" id="templateModelStatus">Template: Not Ready</span>
                <span class="model-indicator not-ready" id="neuralModelStatus">Neural: Not Ready</span>
            </div>
            <div class="model-source-info none" id="modelSourceInfo">Model: None</div>
            <div class="progress-bar" id="progressBarContainer" style="display: none;">
                <div class="progress-bar-fill" id="progressBar" style="width: 0%"></div>
            </div>
        </div>

        <!-- Training Mode Controls -->
        <div class="controls" id="trainingControls">
            <input type="file" id="fileInput" multiple accept="image/*">
            <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                1. Load Images
            </button>
            <button class="btn btn-warning" id="extractBtn" onclick="extractAllBoundaries()" disabled>
                2. Extract Boundaries
            </button>
            <button class="btn btn-success" id="buildModelBtn" onclick="buildModels()" disabled>
                3. Build Models
            </button>
            <button class="btn btn-primary" id="detectTrainingBtn" onclick="detectTrainingPreview()" disabled>
                4. Detect (Preview)
            </button>
            <button class="btn btn-secondary" id="saveModelBtn" onclick="saveModels()" disabled>
                Save Models
            </button>
            <button class="btn btn-secondary" onclick="loadModels()">
                Load Models
            </button>
            <button class="btn btn-danger" onclick="clearAll()">
                Clear All
            </button>
        </div>

        <!-- Detection Mode Controls -->
        <div class="controls hidden" id="detectionControls">
            <input type="file" id="fileInputDetect" multiple accept="image/*">
            <button class="btn btn-primary" onclick="document.getElementById('fileInputDetect').click()">
                1. Load Images
            </button>
            <button class="btn btn-secondary" onclick="loadModels()">
                Load Models
            </button>
            <button class="btn btn-success" id="detectBtn" onclick="detectAll()" disabled>
                2. Detect Buckets
            </button>
            <button class="btn btn-primary" id="exportBtn" onclick="exportResults()" disabled>
                3. Export Results
            </button>
            <button class="btn btn-danger" onclick="clearDetection()">
                Clear
            </button>
        </div>

        <div class="settings-panel">
            <h3>Settings</h3>

            <!-- Algorithm-specific Settings -->
            <div class="settings-section" id="algorithmSettingsSection">
                <h4>Algorithm Parameters</h4>

                <!-- Ray Settings -->
                <div class="subsettings" id="raySettings">
                    <div class="setting-row">
                        <label>Threshold Factor:</label>
                        <input type="number" id="rayThreshold" value="1.0" min="0.5" max="2.0" step="0.1">
                        <span class="info-badge">× global mean (권장: 0.8-1.2)</span>
                    </div>
                </div>

                <!-- Canny Settings -->
                <div class="subsettings hidden" id="cannyEdgeSettings">
                    <div class="setting-row">
                        <label>Gaussian Sigma:</label>
                        <input type="number" id="cannySigma" value="1.4" min="0.5" max="5" step="0.1">
                        <span class="info-badge">Blur strength (권장: 1.0-2.0)</span>
                    </div>
                    <div class="setting-row">
                        <label>Low Threshold:</label>
                        <input type="number" id="cannyLow" value="20" min="1" max="100">
                        <span class="info-badge">Weak edge (권장: 10-30)</span>
                    </div>
                    <div class="setting-row">
                        <label>High Threshold:</label>
                        <input type="number" id="cannyHigh" value="50" min="10" max="200">
                        <span class="info-badge">Strong edge (권장: 30-80)</span>
                    </div>
                </div>

                <!-- Adaptive Settings -->
                <div class="subsettings hidden" id="adaptiveEdgeSettings">
                    <div class="setting-row">
                        <label>Block Size:</label>
                        <input type="number" id="adaptiveBlock" value="31" min="3" max="101" step="2">
                        <span class="info-badge">Local area (권장: 21-51, 홀수)</span>
                    </div>
                    <div class="setting-row">
                        <label>Constant C:</label>
                        <input type="number" id="adaptiveC" value="10" min="-50" max="50">
                        <span class="info-badge">Sensitivity (권장: 5-20)</span>
                    </div>
                </div>

                <!-- Sobel Settings -->
                <div class="subsettings hidden" id="sobelEdgeSettings">
                    <div class="setting-row">
                        <label>Gradient Threshold:</label>
                        <input type="number" id="sobelThreshold" value="30" min="5" max="100">
                        <span class="info-badge">Edge strength (권장: 20-50)</span>
                    </div>
                </div>

                <!-- Statistical Settings -->
                <div class="subsettings hidden" id="statisticalAlgoSettings">
                    <div class="setting-row">
                        <label>Sigma Threshold:</label>
                        <input type="number" id="sigmaThreshold" value="2.0" min="1.0" max="5.0" step="0.1">
                        <span class="info-badge">Outlier detection (권장: 2-3)</span>
                    </div>
                </div>

                <!-- Template Settings -->
                <div class="subsettings hidden" id="templateAlgoSettings">
                    <div class="setting-row">
                        <label>Match Threshold:</label>
                        <input type="number" id="matchThreshold" value="0.7" min="0.1" max="1.0" step="0.05">
                        <span class="info-badge">NCC score (권장: 0.6-0.8)</span>
                    </div>
                </div>

                <!-- Neural Settings -->
                <div class="subsettings hidden" id="neuralAlgoSettings">
                    <div class="setting-row">
                        <label>Epochs:</label>
                        <input type="number" id="epochs" value="10" min="1" max="100">
                    </div>
                    <div class="setting-row">
                        <label>Batch Size:</label>
                        <input type="number" id="batchSize" value="4" min="1" max="32">
                    </div>
                    <div class="setting-row">
                        <button class="btn btn-primary btn-small" id="loadTfBtn" onclick="loadTensorFlow()">
                            Load TensorFlow.js
                        </button>
                        <span id="tfStatus" style="margin-left: 10px; color: #888;">Not loaded</span>
                    </div>
                </div>

                <!-- Troubleshooting Help -->
                <div class="help-text" style="margin-top: 10px; padding: 10px; background: #1a1a2e; border-radius: 5px; font-size: 11px; color: #888;">
                    <strong style="color: #ffcc00;">⚠️ 모든 점이 시작점 근처에 모여있다면:</strong><br>
                    • <strong>Ray</strong>: 시작점을 어두운(trench 내부) 영역으로 이동, Threshold Factor ↑<br>
                    • <strong>Canny</strong>: High Threshold ↓ (권장: 30-50), Sigma ↑<br>
                    • <strong>Adaptive</strong>: Block Size ↑ (권장: 31-51), Constant C ↓<br>
                    • <strong>Sobel</strong>: Gradient Threshold ↓ (권장: 20-40)
                </div>
            </div>

            <!-- Direction Settings -->
            <div class="settings-section">
                <h4>Scan Direction</h4>
                <div class="setting-row">
                    <label>Direction Angle (deg):</label>
                    <input type="number" id="directionAngle" value="90" min="0" max="359">
                    <span class="info-badge">Main direction to scan</span>
                </div>
                <div class="setting-row">
                    <label>Scan Range (deg):</label>
                    <input type="number" id="scanRange" value="90" min="10" max="180">
                    <span class="info-badge">±range from direction</span>
                </div>
                <div class="setting-row">
                    <label>Angle Step (deg):</label>
                    <input type="number" id="angleStep" value="1" min="0.5" max="5" step="0.5">
                </div>
            </div>

            <!-- Mask Preprocessing Settings -->
            <div class="settings-section">
                <h4>Edge Mask (Preprocessing)</h4>
                <div class="setting-row">
                    <label>
                        <input type="checkbox" id="useMaskGuide" onchange="toggleMaskMode()">
                        Use Edge Mask Guide
                    </label>
                    <span class="info-badge">Training 모드 전처리용</span>
                </div>
                <div class="subsettings" id="maskSettings" style="display: none;">
                    <div class="setting-row">
                        <label>Auto-detect Method:</label>
                        <select id="maskDetectMethod">
                            <option value="canny">Canny Edge</option>
                            <option value="sobel">Sobel Gradient</option>
                            <option value="adaptive">Adaptive Threshold</option>
                        </select>
                    </div>
                    <div class="setting-row">
                        <label>Mask Opacity:</label>
                        <input type="range" id="maskOpacity" value="50" min="10" max="90" oninput="updateMaskOpacity()">
                        <span id="maskOpacityValue">50%</span>
                    </div>
                    <div class="setting-row">
                        <label>Brush Size:</label>
                        <input type="number" id="maskBrushSize" value="10" min="2" max="50">
                        <span class="info-badge">Draw/Erase brush size</span>
                    </div>
                    <p class="help-text" style="margin-top: 10px;">
                        <strong style="color: #00d9ff;">사용법:</strong><br>
                        1. 이미지 클릭 → 시작점 설정<br>
                        2. [Auto Detect] → Edge 자동 감지<br>
                        3. [Draw]/[Erase] → 마스크 수정<br>
                        4. [Apply Mask] → 마스크 기반 경계 추출
                    </p>
                </div>
            </div>

            <!-- Noise Filter Settings -->
            <div class="settings-section">
                <h4>Noise Filtering</h4>
                <div class="setting-row">
                    <label>Filter Method:</label>
                    <select id="noiseFilter" onchange="updateFilterSettings()">
                        <option value="fft">FFT Frequency Analysis</option>
                        <option value="consistency">Shape Consistency</option>
                        <option value="ransac">RANSAC Fitting</option>
                        <option value="all">All Methods (Compare)</option>
                    </select>
                </div>

                <!-- FFT Settings -->
                <div class="subsettings" id="fftSettings">
                    <div class="setting-row">
                        <label>Cutoff Frequency:</label>
                        <input type="number" id="fftCutoff" value="0.1" min="0.01" max="0.5" step="0.01">
                        <span class="info-badge">Lower = more smoothing</span>
                    </div>
                </div>

                <!-- Consistency Settings -->
                <div class="subsettings hidden" id="consistencySettings">
                    <div class="setting-row">
                        <label>Max Derivative:</label>
                        <input type="number" id="maxDerivative" value="5.0" min="1.0" max="20.0" step="0.5">
                        <span class="info-badge">Max dr/dθ allowed</span>
                    </div>
                </div>

                <!-- RANSAC Settings -->
                <div class="subsettings hidden" id="ransacSettings">
                    <div class="setting-row">
                        <label>Iterations:</label>
                        <input type="number" id="ransacIterations" value="100" min="10" max="1000" step="10">
                    </div>
                    <div class="setting-row">
                        <label>Inlier Threshold:</label>
                        <input type="number" id="ransacThreshold" value="3.0" min="0.5" max="10.0" step="0.5">
                        <span class="info-badge">Distance in pixels</span>
                    </div>
                    <div class="setting-row">
                        <label>Polynomial Degree:</label>
                        <input type="number" id="polyDegree" value="3" min="2" max="6">
                    </div>
                </div>
            </div>

            <p class="help-text">
                Click on an image to set the start point. The boundary will be extracted in the specified direction.
            </p>
        </div>

        <div class="image-grid" id="imageGrid"></div>
    </div>

    <script>
        // ============================================
        // GLOBAL STATE
        // ============================================
        const state = {
            mode: 'training',
            images: [],
            sourceIndex: null,
            trainingData: {
                contours: [],
                meanProfile: null,
                stdProfile: null,
                templates: [],
                tfModel: null,
                angleConfig: null,
                modelSource: null,      // 'built' | 'loaded'
                loadedFileName: null
            },
            tfLoaded: false
        };

        // ============================================
        // FILE INPUT HANDLERS
        // ============================================
        document.getElementById('fileInput').addEventListener('change', (e) => handleFileUpload(e, 'training'));
        document.getElementById('fileInputDetect').addEventListener('change', (e) => handleFileUpload(e, 'detection'));

        // ============================================
        // MODE SWITCHING
        // ============================================
        function switchMode(mode) {
            state.mode = mode;
            document.getElementById('tabTraining').classList.toggle('active', mode === 'training');
            document.getElementById('tabDetection').classList.toggle('active', mode === 'detection');
            document.getElementById('trainingControls').classList.toggle('hidden', mode !== 'training');
            document.getElementById('detectionControls').classList.toggle('hidden', mode !== 'detection');

            if (mode === 'detection') {
                updateStatus('Detection mode - Load images and detect bucket shapes');
            } else {
                updateStatus('Training mode - Load images to build shape models');
            }
        }

        // ============================================
        // SETTINGS UI HANDLERS
        // ============================================
        // Note: updateMethodSettings() removed - updateAlgorithmUI() handles algorithm-specific settings

        function updateFilterSettings() {
            const filter = document.getElementById('noiseFilter').value;
            document.getElementById('fftSettings').classList.toggle('hidden', filter !== 'fft' && filter !== 'all');
            document.getElementById('consistencySettings').classList.toggle('hidden', filter !== 'consistency' && filter !== 'all');
            document.getElementById('ransacSettings').classList.toggle('hidden', filter !== 'ransac' && filter !== 'all');
        }

        // ============================================
        // IMAGE LOADING
        // ============================================
        async function handleFileUpload(e, mode) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            updateStatus('Loading images...');
            const grid = document.getElementById('imageGrid');

            if (mode === 'detection') {
                // Clear previous detection images
                state.images = state.images.filter(img => img.mode === 'training');
                grid.innerHTML = '';
                // Re-add training images if any
                state.images.forEach((img, i) => {
                    if (img.mode === 'training') {
                        // Re-render training images (simplified)
                    }
                });
            }

            for (const file of files) {
                const img = await loadImage(file);
                const index = state.images.length;

                const card = document.createElement('div');
                card.className = 'image-card';
                card.id = `card-${index}`;
                card.innerHTML = `
                    <h3>${file.name}</h3>
                    <div class="canvas-container">
                        <canvas id="canvas-${index}"></canvas>
                        <canvas id="mask-canvas-${index}" class="mask-canvas"></canvas>
                    </div>
                    <div class="coord-info">
                        Start Point: <span id="coord-${index}">Not set</span>
                    </div>
                    <div class="mask-controls" id="mask-controls-${index}" style="display:none;">
                        <button class="mask-btn-auto" onclick="autoDetectMask(${index})">Auto Detect</button>
                        <button class="mask-btn-draw" id="mask-draw-${index}" onclick="setMaskMode(${index}, 'draw')">Draw</button>
                        <button class="mask-btn-erase" id="mask-erase-${index}" onclick="setMaskMode(${index}, 'erase')">Erase</button>
                        <button class="mask-btn-clear" onclick="clearMask(${index})">Clear</button>
                        <button class="mask-btn-apply" onclick="applyMaskBoundary(${index})">Apply Mask</button>
                    </div>
                    <div class="mask-status" id="mask-status-${index}"></div>
                    <div class="measurement-preview" id="preview-${index}" style="display:none;"></div>
                `;
                grid.appendChild(card);

                const canvas = document.getElementById(`canvas-${index}`);
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);

                // Initialize mask canvas
                const maskCanvas = document.getElementById(`mask-canvas-${index}`);
                const maskCtx = maskCanvas.getContext('2d');
                maskCanvas.width = img.width;
                maskCanvas.height = img.height;
                maskCanvas.style.maxWidth = '100%';
                maskCanvas.style.height = 'auto';

                const imageData = ctx.getImageData(0, 0, img.width, img.height);
                const grayData = toGrayscale(imageData);

                state.images.push({
                    name: file.name,
                    element: img,
                    canvas: canvas,
                    ctx: ctx,
                    maskCanvas: maskCanvas,
                    maskCtx: maskCtx,
                    maskData: null,  // Uint8Array for mask (0 or 255)
                    maskMode: null,  // 'draw' | 'erase' | null
                    grayData: grayData,
                    width: img.width,
                    height: img.height,
                    startPoint: null,
                    boundary: null,
                    filteredBoundary: null,
                    globalMean: calculateGlobalMean(grayData),
                    mode: mode
                });

                canvas.addEventListener('click', (e) => handleCanvasClick(e, index));
                setupMaskCanvasEvents(index);
            }

            updateCounts();
            updateStatus(`${files.length} images loaded. Click to set start points.`);
            updateButtons();
            e.target.value = '';
        }

        function loadImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // ============================================
        // CORE IMAGE PROCESSING
        // ============================================
        function toGrayscale(imageData) {
            const data = imageData.data;
            const gray = new Float32Array(imageData.width * imageData.height);
            for (let i = 0; i < gray.length; i++) {
                const idx = i * 4;
                gray[i] = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
            }
            return gray;
        }

        function calculateGlobalMean(grayData) {
            let sum = 0;
            for (let i = 0; i < grayData.length; i++) {
                sum += grayData[i];
            }
            return sum / grayData.length;
        }

        function bilinearSample(grayData, width, height, x, y) {
            const x0 = Math.floor(x);
            const y0 = Math.floor(y);
            const x1 = Math.min(x0 + 1, width - 1);
            const y1 = Math.min(y0 + 1, height - 1);
            const wx = x - x0;
            const wy = y - y0;

            const i00 = grayData[y0 * width + x0];
            const i10 = grayData[y0 * width + x1];
            const i01 = grayData[y1 * width + x0];
            const i11 = grayData[y1 * width + x1];

            return (1 - wx) * (1 - wy) * i00 +
                   wx * (1 - wy) * i10 +
                   (1 - wx) * wy * i01 +
                   wx * wy * i11;
        }

        // ============================================
        // CANVAS INTERACTION
        // ============================================
        function handleCanvasClick(e, index) {
            const canvas = state.images[index].canvas;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.round((e.clientX - rect.left) * scaleX);
            const y = Math.round((e.clientY - rect.top) * scaleY);

            setStartPoint(index, x, y);
            state.sourceIndex = index;

            document.querySelectorAll('.image-card').forEach(c => c.classList.remove('selected'));
            document.getElementById(`card-${index}`).classList.add('selected');

            updateStatus(`Start point set at (${x}, ${y}) on "${state.images[index].name}"`);
            updateButtons();
        }

        function setStartPoint(index, x, y) {
            const img = state.images[index];
            img.startPoint = { x, y };
            redrawCanvas(index);
            document.getElementById(`coord-${index}`).textContent = `(${x}, ${y})`;
            updateCounts();
        }

        function redrawCanvas(index) {
            const img = state.images[index];
            const ctx = img.ctx;

            ctx.drawImage(img.element, 0, 0);

            // Draw start point
            if (img.startPoint) {
                ctx.beginPath();
                ctx.arc(img.startPoint.x, img.startPoint.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw direction indicator
                const dirAngle = parseFloat(document.getElementById('directionAngle').value) * Math.PI / 180;
                const range = parseFloat(document.getElementById('scanRange').value) * Math.PI / 180;
                const lineLen = 30;

                ctx.beginPath();
                ctx.moveTo(img.startPoint.x, img.startPoint.y);
                ctx.lineTo(
                    img.startPoint.x + lineLen * Math.cos(dirAngle),
                    img.startPoint.y + lineLen * Math.sin(dirAngle)
                );
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw range arc
                ctx.beginPath();
                ctx.arc(img.startPoint.x, img.startPoint.y, 20, dirAngle - range, dirAngle + range);
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.4)';
                ctx.stroke();
            }

            // Draw boundary points
            if (img.boundary && img.boundary.length > 0) {
                ctx.fillStyle = 'rgba(0, 255, 136, 0.6)';
                for (const p of img.boundary) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw filtered boundary if exists
                if (img.filteredBoundary && img.filteredBoundary.length > 0) {
                    ctx.strokeStyle = 'rgba(0, 217, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(img.filteredBoundary[0].x, img.filteredBoundary[0].y);
                    for (let i = 1; i < img.filteredBoundary.length; i++) {
                        ctx.lineTo(img.filteredBoundary[i].x, img.filteredBoundary[i].y);
                    }
                    ctx.stroke();

                    // Draw yellow dots on filtered boundary points
                    const labelInterval = Math.max(1, Math.floor(img.filteredBoundary.length / 12));
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.95)';
                    for (let i = 0; i < img.filteredBoundary.length; i += labelInterval) {
                        const p = img.filteredBoundary[i];
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        // ============================================
        // MASK PREPROCESSING
        // ============================================
        function toggleMaskMode() {
            const useMask = document.getElementById('useMaskGuide').checked;
            document.getElementById('maskSettings').style.display = useMask ? 'block' : 'none';

            // Show/hide mask controls for all images
            state.images.forEach((img, i) => {
                const controls = document.getElementById(`mask-controls-${i}`);
                if (controls) {
                    controls.style.display = useMask ? 'flex' : 'none';
                }
                // Clear mask mode when disabled
                if (!useMask && img.maskCanvas) {
                    img.maskMode = null;
                    img.maskCanvas.classList.remove('editing');
                }
            });
        }

        function updateMaskOpacity() {
            const opacity = document.getElementById('maskOpacity').value;
            document.getElementById('maskOpacityValue').textContent = `${opacity}%`;

            state.images.forEach(img => {
                if (img.maskCanvas) {
                    img.maskCanvas.style.opacity = opacity / 100;
                }
            });
        }

        function setupMaskCanvasEvents(index) {
            const img = state.images[index];
            if (!img || !img.maskCanvas) return;

            let isDrawing = false;

            img.maskCanvas.addEventListener('mousedown', (e) => {
                if (!img.maskMode) return;
                isDrawing = true;
                drawOnMask(e, index);
            });

            img.maskCanvas.addEventListener('mousemove', (e) => {
                if (!isDrawing || !img.maskMode) return;
                drawOnMask(e, index);
            });

            img.maskCanvas.addEventListener('mouseup', () => {
                isDrawing = false;
            });

            img.maskCanvas.addEventListener('mouseleave', () => {
                isDrawing = false;
            });
        }

        function drawOnMask(e, index) {
            const img = state.images[index];
            if (!img || !img.maskCanvas || !img.maskMode) return;

            const rect = img.maskCanvas.getBoundingClientRect();
            const scaleX = img.maskCanvas.width / rect.width;
            const scaleY = img.maskCanvas.height / rect.height;
            const x = Math.round((e.clientX - rect.left) * scaleX);
            const y = Math.round((e.clientY - rect.top) * scaleY);

            const brushSize = parseInt(document.getElementById('maskBrushSize').value) || 10;
            const ctx = img.maskCtx;

            // Initialize mask data if needed
            if (!img.maskData) {
                img.maskData = new Uint8Array(img.width * img.height);
            }

            // Draw on mask
            const isDrawMode = img.maskMode === 'draw';
            ctx.beginPath();
            ctx.arc(x, y, brushSize, 0, Math.PI * 2);

            if (isDrawMode) {
                ctx.fillStyle = 'rgba(0, 255, 0, 1)';
                ctx.fill();
            } else {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
            }

            // Update mask data
            for (let dy = -brushSize; dy <= brushSize; dy++) {
                for (let dx = -brushSize; dx <= brushSize; dx++) {
                    if (dx * dx + dy * dy <= brushSize * brushSize) {
                        const px = x + dx;
                        const py = y + dy;
                        if (px >= 0 && px < img.width && py >= 0 && py < img.height) {
                            img.maskData[py * img.width + px] = isDrawMode ? 255 : 0;
                        }
                    }
                }
            }

            updateMaskStatus(index);
        }

        function setMaskMode(index, mode) {
            const img = state.images[index];
            if (!img) return;

            // Toggle mode
            if (img.maskMode === mode) {
                img.maskMode = null;
                img.maskCanvas.classList.remove('editing');
            } else {
                img.maskMode = mode;
                img.maskCanvas.classList.add('editing');
            }

            // Update button states
            document.getElementById(`mask-draw-${index}`).classList.toggle('active', img.maskMode === 'draw');
            document.getElementById(`mask-erase-${index}`).classList.toggle('active', img.maskMode === 'erase');

            updateMaskStatus(index);
        }

        function clearMask(index) {
            const img = state.images[index];
            if (!img || !img.maskCanvas) return;

            img.maskCtx.clearRect(0, 0, img.width, img.height);
            img.maskData = null;
            updateMaskStatus(index);
        }

        function updateMaskStatus(index) {
            const img = state.images[index];
            const statusEl = document.getElementById(`mask-status-${index}`);
            if (!statusEl) return;

            if (!img.maskData) {
                statusEl.textContent = 'Mask: Empty';
                statusEl.className = 'mask-status';
            } else {
                const maskPixels = img.maskData.reduce((sum, v) => sum + (v > 0 ? 1 : 0), 0);
                statusEl.textContent = `Mask: ${maskPixels.toLocaleString()} pixels | Mode: ${img.maskMode || 'view'}`;
                statusEl.className = 'mask-status active';
            }
        }

        function autoDetectMask(index) {
            const img = state.images[index];
            if (!img) return;

            const method = document.getElementById('maskDetectMethod').value;
            updateStatus(`Generating edge mask using ${method}...`);

            // Generate edge map based on selected method
            let edgeMap;
            const { grayData, width, height } = img;

            switch (method) {
                case 'canny':
                    const sigma = parseFloat(document.getElementById('cannySigma').value) || 1.4;
                    const lowThreshold = parseFloat(document.getElementById('cannyLow').value) || 20;
                    const highThreshold = parseFloat(document.getElementById('cannyHigh').value) || 50;
                    edgeMap = performCannyEdgeDetection(grayData, width, height, sigma, lowThreshold, highThreshold);
                    break;

                case 'sobel':
                    const sobelThreshold = parseFloat(document.getElementById('sobelThreshold').value) || 30;
                    edgeMap = computeSobelEdgeMap(grayData, width, height, sobelThreshold);
                    break;

                case 'adaptive':
                    const blockSize = parseInt(document.getElementById('adaptiveBlock').value) || 31;
                    const thresholdC = parseFloat(document.getElementById('adaptiveC').value) || 10;
                    const integral = computeIntegralImage(grayData, width, height);
                    edgeMap = computeAdaptiveBinary(grayData, integral, width, height, blockSize, thresholdC);
                    break;

                default:
                    edgeMap = performCannyEdgeDetection(grayData, width, height, 1.4, 20, 50);
            }

            // Store mask data
            img.maskData = new Uint8Array(edgeMap);

            // Draw mask on canvas
            renderMaskToCanvas(index);
            updateMaskStatus(index);
            updateStatus(`Edge mask generated using ${method}. You can edit with Draw/Erase.`);
        }

        function computeSobelEdgeMap(grayData, width, height, threshold) {
            const edgeMap = new Uint8Array(width * height);

            const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
            const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;
                    let ki = 0;

                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = (y + ky) * width + (x + kx);
                            const val = grayData[idx];
                            gx += val * sobelX[ki];
                            gy += val * sobelY[ki];
                            ki++;
                        }
                    }

                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    edgeMap[y * width + x] = magnitude > threshold ? 255 : 0;
                }
            }

            return edgeMap;
        }

        function renderMaskToCanvas(index) {
            const img = state.images[index];
            if (!img || !img.maskCanvas || !img.maskData) return;

            const ctx = img.maskCtx;
            ctx.clearRect(0, 0, img.width, img.height);

            const imageData = ctx.createImageData(img.width, img.height);
            const data = imageData.data;

            for (let i = 0; i < img.maskData.length; i++) {
                const idx = i * 4;
                if (img.maskData[i] > 0) {
                    data[idx] = 0;       // R
                    data[idx + 1] = 255; // G
                    data[idx + 2] = 0;   // B
                    data[idx + 3] = 255; // A
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function applyMaskBoundary(index) {
            const img = state.images[index];
            if (!img || !img.maskData || !img.startPoint) {
                alert('시작점을 먼저 설정하고 마스크를 생성하세요.');
                return;
            }

            const directionDeg = parseFloat(document.getElementById('directionAngle').value);
            const rangeDeg = parseFloat(document.getElementById('scanRange').value);
            const stepDeg = parseFloat(document.getElementById('angleStep').value);

            // Extract boundary using mask
            img.boundary = extractBoundaryFromMask(img, directionDeg, rangeDeg, stepDeg);

            // Apply noise filter
            const filter = document.getElementById('noiseFilter').value;
            img.filteredBoundary = applyNoiseFilter(img.boundary, filter, img);

            redrawCanvas(index);

            // Check for clustered points
            const clusterCheck = checkClusteredPoints(img.boundary, img.startPoint);

            const preview = document.getElementById(`preview-${index}`);
            preview.style.display = 'block';
            let previewHtml = `<strong>Mask-based:</strong> ${img.boundary.length} points`;
            if (img.filteredBoundary) {
                previewHtml += ` | <strong>Filtered:</strong> ${img.filteredBoundary.length} points`;
            }
            if (clusterCheck.clustered) {
                previewHtml += ` | <span style="color: #ff4444;">⚠️ Clustered</span>`;
            }
            preview.innerHTML = previewHtml;

            updateStatus(`Mask-based boundary extracted: ${img.boundary.length} points`);

            // Add to training data if in training mode
            if (img.mode === 'training') {
                const existingIdx = state.trainingData.contours.findIndex(c => c.imageIndex === index);
                if (existingIdx >= 0) {
                    state.trainingData.contours[existingIdx].points = img.boundary;
                } else {
                    state.trainingData.contours.push({
                        imageIndex: index,
                        points: img.boundary
                    });
                }
                state.trainingData.angleConfig = { directionDeg, rangeDeg, stepDeg };
                updateCounts();
                updateButtons();
            }
        }

        function extractBoundaryFromMask(img, directionDeg, rangeDeg, stepDeg) {
            const { startPoint, grayData, width, height, maskData } = img;
            const results = [];

            const startAngle = directionDeg - rangeDeg;
            const endAngle = directionDeg + rangeDeg;
            const maxRadius = Math.ceil(Math.hypot(
                Math.max(startPoint.x, width - startPoint.x),
                Math.max(startPoint.y, height - startPoint.y)
            ));

            for (let angle = startAngle; angle <= endAngle; angle += stepDeg) {
                const rad = angle * Math.PI / 180;
                const dx = Math.cos(rad);
                const dy = Math.sin(rad);

                for (let r = 1; r < maxRadius; r++) {
                    const x = Math.round(startPoint.x + r * dx);
                    const y = Math.round(startPoint.y + r * dy);

                    if (x < 0 || x >= width || y < 0 || y >= height) break;

                    // Check if this point is on the mask
                    if (maskData[y * width + x] > 0) {
                        results.push({
                            angle: angle,
                            radius: r,
                            x: startPoint.x + r * dx,
                            y: startPoint.y + r * dy,
                            intensity: grayData[y * width + x]
                        });
                        break;
                    }
                }
            }

            return results;
        }

        // ============================================
        // BOUNDARY EXTRACTION (Method Router)
        // ============================================
        function extractBoundary(img, directionDeg, rangeDeg, stepDeg) {
            const algorithm = document.getElementById('mainAlgorithm').value;

            // For Edge Detection algorithms, use directly
            // For Shape Learning algorithms, use Ray as base extraction method
            switch (algorithm) {
                case 'ray':
                    return extractBoundaryRay(img, directionDeg, rangeDeg, stepDeg);
                case 'canny':
                    return extractBoundaryCanny(img, directionDeg, rangeDeg, stepDeg);
                case 'adaptive':
                    return extractBoundaryAdaptive(img, directionDeg, rangeDeg, stepDeg);
                case 'sobel':
                    return extractBoundarySobel(img, directionDeg, rangeDeg, stepDeg);
                // Shape Learning algorithms use Ray as base extraction
                case 'statistical':
                case 'template':
                case 'neural':
                default:
                    return extractBoundaryRay(img, directionDeg, rangeDeg, stepDeg);
            }
        }

        // ============================================
        // RAY-CASTING EDGE DETECTION
        // ============================================
        function extractBoundaryRay(img, directionDeg, rangeDeg, stepDeg) {
            const { startPoint, grayData, width, height, globalMean } = img;
            const results = [];
            const thresholdFactor = parseFloat(document.getElementById('rayThreshold').value) || 1.0;
            const threshold = globalMean * thresholdFactor;

            const startAngle = directionDeg - rangeDeg;
            const endAngle = directionDeg + rangeDeg;
            const maxRadius = Math.ceil(Math.hypot(
                Math.max(startPoint.x, width - startPoint.x),
                Math.max(startPoint.y, height - startPoint.y)
            ));

            for (let angle = startAngle; angle <= endAngle; angle += stepDeg) {
                const rad = angle * Math.PI / 180;
                const dx = Math.cos(rad);
                const dy = Math.sin(rad);

                for (let r = 1; r < maxRadius; r++) {
                    const x = startPoint.x + r * dx;
                    const y = startPoint.y + r * dy;

                    if (x < 0 || x >= width || y < 0 || y >= height) break;

                    const intensity = bilinearSample(grayData, width, height, x, y);

                    if (intensity > threshold) {
                        results.push({
                            angle: angle,
                            radius: r,
                            x: x,
                            y: y,
                            intensity: intensity
                        });
                        break;
                    }
                }
            }

            return results;
        }

        // ============================================
        // CANNY EDGE DETECTION
        // ============================================
        function generateGaussianKernel(sigma) {
            let size = Math.ceil(sigma * 6) | 1;
            if (size < 3) size = 3;

            const kernel = [];
            const center = Math.floor(size / 2);
            let sum = 0;

            for (let y = 0; y < size; y++) {
                const row = [];
                for (let x = 0; x < size; x++) {
                    const dx = x - center;
                    const dy = y - center;
                    const value = Math.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));
                    row.push(value);
                    sum += value;
                }
                kernel.push(row);
            }

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    kernel[y][x] /= sum;
                }
            }
            return kernel;
        }

        function applyGaussianBlur(grayData, width, height, sigma) {
            const kernel = generateGaussianKernel(sigma);
            const kSize = kernel.length;
            const kHalf = Math.floor(kSize / 2);
            const result = new Float32Array(width * height);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let sum = 0;
                    let weightSum = 0;

                    for (let ky = 0; ky < kSize; ky++) {
                        for (let kx = 0; kx < kSize; kx++) {
                            const px = x + kx - kHalf;
                            const py = y + ky - kHalf;

                            if (px >= 0 && px < width && py >= 0 && py < height) {
                                const weight = kernel[ky][kx];
                                sum += grayData[py * width + px] * weight;
                                weightSum += weight;
                            }
                        }
                    }
                    result[y * width + x] = sum / weightSum;
                }
            }
            return result;
        }

        function computeGradients(blurredData, width, height) {
            const sobelX = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
            const sobelY = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];

            const gradientMagnitude = new Float32Array(width * height);
            const gradientDirection = new Float32Array(width * height);

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;

                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const pixel = blurredData[(y + ky) * width + (x + kx)];
                            gx += pixel * sobelX[ky + 1][kx + 1];
                            gy += pixel * sobelY[ky + 1][kx + 1];
                        }
                    }

                    const idx = y * width + x;
                    gradientMagnitude[idx] = Math.sqrt(gx * gx + gy * gy);
                    gradientDirection[idx] = Math.atan2(gy, gx);
                }
            }
            return { gradientMagnitude, gradientDirection };
        }

        function nonMaximumSuppression(gradientMagnitude, gradientDirection, width, height) {
            const result = new Float32Array(width * height);

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    const magnitude = gradientMagnitude[idx];
                    if (magnitude === 0) continue;

                    let angle = gradientDirection[idx] * 180 / Math.PI;
                    if (angle < 0) angle += 180;

                    let neighbor1, neighbor2;

                    if ((angle >= 0 && angle < 22.5) || (angle >= 157.5 && angle <= 180)) {
                        neighbor1 = gradientMagnitude[y * width + (x - 1)];
                        neighbor2 = gradientMagnitude[y * width + (x + 1)];
                    } else if (angle >= 22.5 && angle < 67.5) {
                        neighbor1 = gradientMagnitude[(y - 1) * width + (x + 1)];
                        neighbor2 = gradientMagnitude[(y + 1) * width + (x - 1)];
                    } else if (angle >= 67.5 && angle < 112.5) {
                        neighbor1 = gradientMagnitude[(y - 1) * width + x];
                        neighbor2 = gradientMagnitude[(y + 1) * width + x];
                    } else {
                        neighbor1 = gradientMagnitude[(y - 1) * width + (x - 1)];
                        neighbor2 = gradientMagnitude[(y + 1) * width + (x + 1)];
                    }

                    if (magnitude >= neighbor1 && magnitude >= neighbor2) {
                        result[idx] = magnitude;
                    }
                }
            }
            return result;
        }

        function hysteresisThreshold(suppressedData, width, height, lowThreshold, highThreshold) {
            const edges = new Uint8Array(width * height);
            const WEAK = 128;
            const STRONG = 255;

            for (let i = 0; i < suppressedData.length; i++) {
                if (suppressedData[i] >= highThreshold) {
                    edges[i] = STRONG;
                } else if (suppressedData[i] >= lowThreshold) {
                    edges[i] = WEAK;
                }
            }

            const queue = [];
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    if (edges[y * width + x] === STRONG) {
                        queue.push({ x, y });
                    }
                }
            }

            while (queue.length > 0) {
                const { x, y } = queue.shift();
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const nIdx = ny * width + nx;
                            if (edges[nIdx] === WEAK) {
                                edges[nIdx] = STRONG;
                                queue.push({ x: nx, y: ny });
                            }
                        }
                    }
                }
            }

            for (let i = 0; i < edges.length; i++) {
                if (edges[i] !== STRONG) edges[i] = 0;
            }
            return edges;
        }

        function performCannyEdgeDetection(grayData, width, height, sigma, lowThreshold, highThreshold) {
            const blurred = applyGaussianBlur(grayData, width, height, sigma);
            const { gradientMagnitude, gradientDirection } = computeGradients(blurred, width, height);
            const suppressed = nonMaximumSuppression(gradientMagnitude, gradientDirection, width, height);
            const edges = hysteresisThreshold(suppressed, width, height, lowThreshold, highThreshold);
            return edges;
        }

        function extractBoundaryCanny(img, directionDeg, rangeDeg, stepDeg) {
            const { startPoint, grayData, width, height } = img;
            const results = [];

            const sigma = parseFloat(document.getElementById('cannySigma').value) || 1.4;
            const lowThreshold = parseFloat(document.getElementById('cannyLow').value) || 20;
            const highThreshold = parseFloat(document.getElementById('cannyHigh').value) || 50;

            const edgeMap = performCannyEdgeDetection(grayData, width, height, sigma, lowThreshold, highThreshold);
            img.edgeMap = edgeMap;

            const startAngle = directionDeg - rangeDeg;
            const endAngle = directionDeg + rangeDeg;
            const maxRadius = Math.ceil(Math.hypot(
                Math.max(startPoint.x, width - startPoint.x),
                Math.max(startPoint.y, height - startPoint.y)
            ));

            for (let angle = startAngle; angle <= endAngle; angle += stepDeg) {
                const rad = angle * Math.PI / 180;
                const dx = Math.cos(rad);
                const dy = Math.sin(rad);

                for (let r = 1; r < maxRadius; r++) {
                    const x = Math.round(startPoint.x + r * dx);
                    const y = Math.round(startPoint.y + r * dy);

                    if (x < 1 || x >= width - 1 || y < 1 || y >= height - 1) break;

                    if (edgeMap[y * width + x] === 255) {
                        results.push({
                            angle: angle,
                            radius: r,
                            x: startPoint.x + r * dx,
                            y: startPoint.y + r * dy,
                            intensity: grayData[y * width + x]
                        });
                        break;
                    }
                }
            }

            return results;
        }

        // ============================================
        // ADAPTIVE THRESHOLD EDGE DETECTION
        // ============================================
        function computeIntegralImage(grayData, width, height) {
            const integral = new Float64Array(width * height);

            for (let y = 0; y < height; y++) {
                let rowSum = 0;
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    rowSum += grayData[idx];
                    integral[idx] = rowSum + (y > 0 ? integral[(y - 1) * width + x] : 0);
                }
            }
            return integral;
        }

        function getLocalMean(integral, width, height, x, y, blockRadius) {
            const x1 = Math.max(0, x - blockRadius);
            const y1 = Math.max(0, y - blockRadius);
            const x2 = Math.min(width - 1, x + blockRadius);
            const y2 = Math.min(height - 1, y + blockRadius);

            const A = (y1 > 0 && x1 > 0) ? integral[(y1 - 1) * width + (x1 - 1)] : 0;
            const B = (y1 > 0) ? integral[(y1 - 1) * width + x2] : 0;
            const C = (x1 > 0) ? integral[y2 * width + (x1 - 1)] : 0;
            const D = integral[y2 * width + x2];

            const sum = D - B - C + A;
            const count = (x2 - x1 + 1) * (y2 - y1 + 1);
            return sum / count;
        }

        function computeAdaptiveBinary(grayData, integral, width, height, blockSize, C) {
            const blockRadius = Math.floor(blockSize / 2);
            const binary = new Uint8Array(width * height);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const localMean = getLocalMean(integral, width, height, x, y, blockRadius);
                    const threshold = localMean - C;
                    binary[idx] = grayData[idx] > threshold ? 255 : 0;
                }
            }
            return binary;
        }

        function extractBoundaryAdaptive(img, directionDeg, rangeDeg, stepDeg) {
            const { startPoint, grayData, width, height } = img;
            const results = [];

            const blockSize = parseInt(document.getElementById('adaptiveBlock').value) || 31;
            const thresholdC = parseFloat(document.getElementById('adaptiveC').value) || 10;

            const integral = computeIntegralImage(grayData, width, height);
            const binary = computeAdaptiveBinary(grayData, integral, width, height, blockSize, thresholdC);
            img.edgeMap = binary;

            const startAngle = directionDeg - rangeDeg;
            const endAngle = directionDeg + rangeDeg;

            let prevVal = binary[Math.round(startPoint.y) * width + Math.round(startPoint.x)];

            for (let angle = startAngle; angle <= endAngle; angle += stepDeg) {
                const rad = angle * Math.PI / 180;
                const dx = Math.cos(rad);
                const dy = Math.sin(rad);
                const maxRadius = Math.ceil(Math.hypot(
                    Math.max(startPoint.x, width - startPoint.x),
                    Math.max(startPoint.y, height - startPoint.y)
                ));

                prevVal = binary[Math.round(startPoint.y) * width + Math.round(startPoint.x)];

                for (let r = 1; r < maxRadius; r++) {
                    const x = Math.round(startPoint.x + r * dx);
                    const y = Math.round(startPoint.y + r * dy);

                    if (x < 0 || x >= width || y < 0 || y >= height) break;

                    const currVal = binary[y * width + x];

                    // Transition from dark (0) to white (255) = edge
                    if (prevVal === 0 && currVal === 255) {
                        results.push({
                            angle: angle,
                            radius: r,
                            x: startPoint.x + r * dx,
                            y: startPoint.y + r * dy,
                            intensity: grayData[y * width + x]
                        });
                        break;
                    }
                    prevVal = currVal;
                }
            }

            return results;
        }

        // ============================================
        // SOBEL GRADIENT EDGE DETECTION
        // ============================================
        function extractBoundarySobel(img, directionDeg, rangeDeg, stepDeg) {
            const { startPoint, grayData, width, height } = img;
            const results = [];

            const gradientThreshold = parseFloat(document.getElementById('sobelThreshold').value) || 30;

            // Compute Sobel gradients for entire image
            const sobelX = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
            const sobelY = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];
            const gradientMagnitude = new Float32Array(width * height);

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const pixel = grayData[(y + ky) * width + (x + kx)];
                            gx += pixel * sobelX[ky + 1][kx + 1];
                            gy += pixel * sobelY[ky + 1][kx + 1];
                        }
                    }
                    gradientMagnitude[y * width + x] = Math.sqrt(gx * gx + gy * gy);
                }
            }

            const startAngle = directionDeg - rangeDeg;
            const endAngle = directionDeg + rangeDeg;
            const maxRadius = Math.ceil(Math.hypot(
                Math.max(startPoint.x, width - startPoint.x),
                Math.max(startPoint.y, height - startPoint.y)
            ));

            for (let angle = startAngle; angle <= endAngle; angle += stepDeg) {
                const rad = angle * Math.PI / 180;
                const dx = Math.cos(rad);
                const dy = Math.sin(rad);

                // Find peak gradient along ray
                let maxGrad = 0;
                let maxR = 0;

                for (let r = 3; r < maxRadius; r++) {
                    const x = Math.round(startPoint.x + r * dx);
                    const y = Math.round(startPoint.y + r * dy);

                    if (x < 1 || x >= width - 1 || y < 1 || y >= height - 1) break;

                    const grad = gradientMagnitude[y * width + x];
                    if (grad > maxGrad && grad >= gradientThreshold) {
                        maxGrad = grad;
                        maxR = r;
                    }
                }

                if (maxR > 0) {
                    const x = startPoint.x + maxR * dx;
                    const y = startPoint.y + maxR * dy;
                    results.push({
                        angle: angle,
                        radius: maxR,
                        x: x,
                        y: y,
                        intensity: grayData[Math.round(y) * width + Math.round(x)]
                    });
                }
            }

            return results;
        }

        async function extractAllBoundaries() {
            const imagesWithPoints = state.images.filter(img => img.startPoint && img.mode === 'training');
            if (imagesWithPoints.length === 0) {
                alert('Set start points on training images first.');
                return;
            }

            const algorithm = document.getElementById('mainAlgorithm').value;
            const directionDeg = parseFloat(document.getElementById('directionAngle').value);
            const rangeDeg = parseFloat(document.getElementById('scanRange').value);
            const stepDeg = parseFloat(document.getElementById('angleStep').value);

            updateStatus('Extracting boundaries...');
            showProgress(true);

            state.trainingData.contours = [];
            state.trainingData.angleConfig = { directionDeg, rangeDeg, stepDeg };

            let processed = 0;
            let clusteredCount = 0;

            for (let i = 0; i < state.images.length; i++) {
                const img = state.images[i];
                if (!img.startPoint || img.mode !== 'training') continue;

                img.boundary = extractBoundary(img, directionDeg, rangeDeg, stepDeg);
                state.trainingData.contours.push({
                    imageIndex: i,
                    points: img.boundary
                });

                // Check for clustered points
                const clusterCheck = checkClusteredPoints(img.boundary, img.startPoint);
                if (clusterCheck.clustered) {
                    clusteredCount++;
                }

                redrawCanvas(i);

                const preview = document.getElementById(`preview-${i}`);
                preview.style.display = 'block';
                let previewHtml = `<strong>Boundary:</strong> ${img.boundary.length} points extracted`;
                if (clusterCheck.clustered) {
                    previewHtml += ` | <span style="color: #ff4444;">⚠️ Clustered (mean: ${clusterCheck.meanRadius.toFixed(1)}px)</span>`;
                }
                preview.innerHTML = previewHtml;

                processed++;
                updateProgress(processed / imagesWithPoints.length * 100);
                await new Promise(resolve => setTimeout(resolve, 0));
            }

            showProgress(false);

            // Show clustered warning if all images have clustered points
            if (clusteredCount > 0 && clusteredCount === processed) {
                showClusteredWarning(algorithm);
                updateStatus(`⚠️ 모든 이미지에서 점이 밀집되어 있습니다. 파라미터를 조정하세요.`);
            } else if (clusteredCount > 0) {
                updateStatus(`Extracted boundaries from ${processed} images. ⚠️ ${clusteredCount}개 이미지에서 점이 밀집됨. Ready to build models.`);
            } else {
                updateStatus(`Extracted boundaries from ${processed} images. Ready to build models.`);
            }
            updateCounts();
            updateButtons();
        }

        // ============================================
        // STATISTICAL MODELING
        // ============================================
        function computeStatisticalModel(contours, angleConfig) {
            const { directionDeg, rangeDeg, stepDeg } = angleConfig;
            const startAngle = directionDeg - rangeDeg;
            const endAngle = directionDeg + rangeDeg;
            const numAngles = Math.ceil((endAngle - startAngle) / stepDeg) + 1;

            const radiusSum = new Float32Array(numAngles);
            const radiusSumSq = new Float32Array(numAngles);
            const counts = new Uint32Array(numAngles);

            for (const contour of contours) {
                for (const p of contour.points) {
                    const idx = Math.round((p.angle - startAngle) / stepDeg);
                    if (idx >= 0 && idx < numAngles) {
                        radiusSum[idx] += p.radius;
                        radiusSumSq[idx] += p.radius * p.radius;
                        counts[idx]++;
                    }
                }
            }

            const meanProfile = new Float32Array(numAngles);
            const stdProfile = new Float32Array(numAngles);

            for (let i = 0; i < numAngles; i++) {
                if (counts[i] > 0) {
                    meanProfile[i] = radiusSum[i] / counts[i];
                    const variance = radiusSumSq[i] / counts[i] - meanProfile[i] * meanProfile[i];
                    stdProfile[i] = Math.sqrt(Math.max(0, variance));
                }
            }

            return { meanProfile, stdProfile, startAngle, stepDeg };
        }

        function applyStatisticalFilter(boundary, model, sigmaThreshold) {
            const { meanProfile, stdProfile, startAngle, stepDeg } = model;
            const filtered = [];

            for (const p of boundary) {
                const idx = Math.round((p.angle - startAngle) / stepDeg);
                if (idx >= 0 && idx < meanProfile.length) {
                    const mean = meanProfile[idx];
                    const std = stdProfile[idx] || 1;
                    const deviation = Math.abs(p.radius - mean) / std;

                    if (deviation <= sigmaThreshold) {
                        filtered.push({ ...p, deviation });
                    }
                }
            }

            return filtered;
        }

        // ============================================
        // TEMPLATE MATCHING
        // ============================================
        function saveTemplate(boundary, name) {
            const radiusProfile = boundary.map(p => p.radius);
            state.trainingData.templates.push({
                name: name,
                profile: radiusProfile,
                angles: boundary.map(p => p.angle)
            });
        }

        function matchTemplate(boundary, templates) {
            if (templates.length === 0) return { score: 0, matched: boundary };

            const radiusProfile = boundary.map(p => p.radius);
            let bestScore = -Infinity;
            let bestTemplate = null;

            for (const template of templates) {
                if (template.profile.length !== radiusProfile.length) continue;

                // Normalized Cross-Correlation
                let sumT = 0, sumI = 0, sumTT = 0, sumII = 0, sumTI = 0;
                const n = radiusProfile.length;

                for (let i = 0; i < n; i++) {
                    const t = template.profile[i];
                    const r = radiusProfile[i];
                    sumT += t;
                    sumI += r;
                    sumTT += t * t;
                    sumII += r * r;
                    sumTI += t * r;
                }

                const meanT = sumT / n;
                const meanI = sumI / n;
                const varT = sumTT / n - meanT * meanT;
                const varI = sumII / n - meanI * meanI;
                const covar = sumTI / n - meanT * meanI;

                const score = (varT > 0 && varI > 0) ? covar / (Math.sqrt(varT) * Math.sqrt(varI)) : 0;

                if (score > bestScore) {
                    bestScore = score;
                    bestTemplate = template;
                }
            }

            return { score: bestScore, template: bestTemplate, matched: boundary };
        }

        // ============================================
        // FFT NOISE FILTERING
        // ============================================
        function fftFilter(boundary, cutoffRatio) {
            const n = boundary.length;
            if (n < 4) return boundary;

            const radii = boundary.map(p => p.radius);

            // Simple DFT
            const real = new Float32Array(n);
            const imag = new Float32Array(n);

            for (let k = 0; k < n; k++) {
                let sumReal = 0, sumImag = 0;
                for (let t = 0; t < n; t++) {
                    const angle = -2 * Math.PI * k * t / n;
                    sumReal += radii[t] * Math.cos(angle);
                    sumImag += radii[t] * Math.sin(angle);
                }
                real[k] = sumReal;
                imag[k] = sumImag;
            }

            // Apply low-pass filter
            const cutoff = Math.floor(n * cutoffRatio);
            for (let k = cutoff; k < n - cutoff; k++) {
                real[k] = 0;
                imag[k] = 0;
            }

            // Inverse DFT
            const filtered = new Float32Array(n);
            for (let t = 0; t < n; t++) {
                let sum = 0;
                for (let k = 0; k < n; k++) {
                    const angle = 2 * Math.PI * k * t / n;
                    sum += real[k] * Math.cos(angle) - imag[k] * Math.sin(angle);
                }
                filtered[t] = sum / n;
            }

            return boundary.map((p, i) => ({
                ...p,
                radius: filtered[i],
                x: p.x + (filtered[i] - p.radius) * Math.cos(p.angle * Math.PI / 180),
                y: p.y + (filtered[i] - p.radius) * Math.sin(p.angle * Math.PI / 180)
            }));
        }

        // ============================================
        // SHAPE CONSISTENCY FILTER
        // ============================================
        function consistencyFilter(boundary, maxDerivative) {
            const n = boundary.length;
            if (n < 3) return boundary;

            const filtered = [...boundary];
            const flagged = new Array(n).fill(false);

            // Calculate derivatives and flag outliers
            for (let i = 1; i < n - 1; i++) {
                const dr = boundary[i + 1].radius - boundary[i - 1].radius;
                const dAngle = boundary[i + 1].angle - boundary[i - 1].angle;
                const derivative = Math.abs(dr / dAngle);

                if (derivative > maxDerivative) {
                    flagged[i] = true;
                }
            }

            // Interpolate flagged points
            for (let i = 1; i < n - 1; i++) {
                if (flagged[i]) {
                    // Find nearest non-flagged neighbors
                    let prevIdx = i - 1;
                    while (prevIdx > 0 && flagged[prevIdx]) prevIdx--;
                    let nextIdx = i + 1;
                    while (nextIdx < n - 1 && flagged[nextIdx]) nextIdx++;

                    const t = (i - prevIdx) / (nextIdx - prevIdx);
                    const interpRadius = boundary[prevIdx].radius * (1 - t) + boundary[nextIdx].radius * t;

                    const angle = boundary[i].angle;
                    const rad = angle * Math.PI / 180;
                    const startX = state.images[0].startPoint?.x || 0;
                    const startY = state.images[0].startPoint?.y || 0;

                    filtered[i] = {
                        ...boundary[i],
                        radius: interpRadius,
                        x: startX + interpRadius * Math.cos(rad),
                        y: startY + interpRadius * Math.sin(rad)
                    };
                }
            }

            return filtered;
        }

        // ============================================
        // RANSAC FITTING
        // ============================================
        function ransacFit(boundary, iterations, threshold, degree) {
            const n = boundary.length;
            if (n < degree + 1) return { inliers: boundary, outliers: [], model: null };

            const minSamples = degree + 1;
            let bestInliers = [];
            let bestModel = null;

            for (let iter = 0; iter < iterations; iter++) {
                // Random sample
                const sampleIndices = [];
                while (sampleIndices.length < minSamples) {
                    const idx = Math.floor(Math.random() * n);
                    if (!sampleIndices.includes(idx)) {
                        sampleIndices.push(idx);
                    }
                }

                const samples = sampleIndices.map(i => boundary[i]);

                // Fit polynomial
                const model = fitPolynomial(samples, degree);
                if (!model) continue;

                // Count inliers
                const inliers = [];
                for (const p of boundary) {
                    const predicted = evaluatePolynomial(model, p.angle);
                    const error = Math.abs(p.radius - predicted);
                    if (error < threshold) {
                        inliers.push(p);
                    }
                }

                if (inliers.length > bestInliers.length) {
                    bestInliers = inliers;
                    bestModel = model;
                }
            }

            // Refit with all inliers
            if (bestInliers.length >= minSamples) {
                bestModel = fitPolynomial(bestInliers, degree);
            }

            const outliers = boundary.filter(p => !bestInliers.includes(p));

            // Generate filtered boundary using model
            const filtered = boundary.map(p => {
                const predictedRadius = evaluatePolynomial(bestModel, p.angle);
                const rad = p.angle * Math.PI / 180;
                const startX = state.images[0].startPoint?.x || 0;
                const startY = state.images[0].startPoint?.y || 0;
                return {
                    ...p,
                    radius: predictedRadius,
                    x: startX + predictedRadius * Math.cos(rad),
                    y: startY + predictedRadius * Math.sin(rad)
                };
            });

            return { inliers: bestInliers, outliers, model: bestModel, filtered };
        }

        function fitPolynomial(points, degree) {
            const n = points.length;
            if (n < degree + 1) return null;

            // Build Vandermonde matrix
            const X = [];
            const y = [];
            for (const p of points) {
                const row = [];
                for (let d = 0; d <= degree; d++) {
                    row.push(Math.pow(p.angle, d));
                }
                X.push(row);
                y.push(p.radius);
            }

            // Solve using normal equations: (X^T X)^-1 X^T y
            const XtX = [];
            const Xty = [];

            for (let i = 0; i <= degree; i++) {
                XtX[i] = [];
                Xty[i] = 0;
                for (let j = 0; j <= degree; j++) {
                    let sum = 0;
                    for (let k = 0; k < n; k++) {
                        sum += X[k][i] * X[k][j];
                    }
                    XtX[i][j] = sum;
                }
                for (let k = 0; k < n; k++) {
                    Xty[i] += X[k][i] * y[k];
                }
            }

            // Solve using Gaussian elimination
            const coeffs = solveLinearSystem(XtX, Xty);
            return coeffs;
        }

        function solveLinearSystem(A, b) {
            const n = b.length;
            const aug = A.map((row, i) => [...row, b[i]]);

            // Forward elimination
            for (let i = 0; i < n; i++) {
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(aug[k][i]) > Math.abs(aug[maxRow][i])) {
                        maxRow = k;
                    }
                }
                [aug[i], aug[maxRow]] = [aug[maxRow], aug[i]];

                if (Math.abs(aug[i][i]) < 1e-10) continue;

                for (let k = i + 1; k < n; k++) {
                    const factor = aug[k][i] / aug[i][i];
                    for (let j = i; j <= n; j++) {
                        aug[k][j] -= factor * aug[i][j];
                    }
                }
            }

            // Back substitution
            const x = new Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) {
                if (Math.abs(aug[i][i]) < 1e-10) continue;
                x[i] = aug[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= aug[i][j] * x[j];
                }
                x[i] /= aug[i][i];
            }

            return x;
        }

        function evaluatePolynomial(coeffs, x) {
            if (!coeffs) return 0;
            let result = 0;
            for (let i = 0; i < coeffs.length; i++) {
                result += coeffs[i] * Math.pow(x, i);
            }
            return result;
        }

        // ============================================
        // BUILD MODELS
        // ============================================
        async function buildModels() {
            if (state.trainingData.contours.length === 0) {
                alert('Extract boundaries first.');
                return;
            }

            const algorithm = document.getElementById('mainAlgorithm').value;
            updateStatus('Building models...');
            showProgress(true);

            // Statistical model - build when statistical is selected or for all shape learning methods
            if (algorithm === 'statistical' || ['template', 'neural'].includes(algorithm)) {
                const model = computeStatisticalModel(state.trainingData.contours, state.trainingData.angleConfig);
                state.trainingData.meanProfile = model.meanProfile;
                state.trainingData.stdProfile = model.stdProfile;
                document.getElementById('statModelStatus').className = 'model-indicator ready';
                document.getElementById('statModelStatus').textContent = 'Statistical: Ready';
                updateProgress(33);
            }

            await new Promise(resolve => setTimeout(resolve, 100));

            // Template model
            if (algorithm === 'template' || algorithm === 'statistical') {
                state.trainingData.templates = [];
                for (let i = 0; i < state.trainingData.contours.length; i++) {
                    saveTemplate(state.trainingData.contours[i].points, `template_${i}`);
                }
                document.getElementById('templateModelStatus').className = 'model-indicator ready';
                document.getElementById('templateModelStatus').textContent = `Template: ${state.trainingData.templates.length} saved`;
                updateProgress(66);
            }

            await new Promise(resolve => setTimeout(resolve, 100));

            // Neural network (placeholder - requires TF.js)
            if (algorithm === 'neural') {
                if (state.tfLoaded) {
                    await trainNeuralModel();
                    document.getElementById('neuralModelStatus').className = 'model-indicator ready';
                    document.getElementById('neuralModelStatus').textContent = 'Neural: Trained';
                } else {
                    document.getElementById('neuralModelStatus').className = 'model-indicator not-ready';
                    document.getElementById('neuralModelStatus').textContent = 'Neural: TF.js not loaded';
                }
                updateProgress(100);
            }

            showProgress(false);
            updateStatus('Models built successfully!');
            state.trainingData.modelSource = 'built';
            state.trainingData.loadedFileName = null;
            updateModelSourceDisplay();
            updateButtons();
        }

        // ============================================
        // TENSORFLOW.JS INTEGRATION
        // ============================================
        async function loadTensorFlow() {
            updateStatus('Loading TensorFlow.js...');
            try {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js';
                document.head.appendChild(script);

                await new Promise((resolve, reject) => {
                    script.onload = resolve;
                    script.onerror = reject;
                });

                state.tfLoaded = true;
                document.getElementById('tfStatus').textContent = 'Loaded';
                document.getElementById('tfStatus').style.color = '#00ff88';
                updateStatus('TensorFlow.js loaded successfully');
            } catch (e) {
                updateStatus('Failed to load TensorFlow.js: ' + e.message);
            }
        }

        async function trainNeuralModel() {
            if (!state.tfLoaded || typeof tf === 'undefined') return;

            const epochs = parseInt(document.getElementById('epochs').value);
            const batchSize = parseInt(document.getElementById('batchSize').value);

            // Prepare training data
            const inputs = [];
            const outputs = [];

            for (const contour of state.trainingData.contours) {
                const img = state.images[contour.imageIndex];
                if (!img) continue;

                // Use grayscale patch around start point as input
                const patchSize = 64;
                const patch = extractPatch(img.grayData, img.width, img.height, img.startPoint.x, img.startPoint.y, patchSize);
                inputs.push(patch);

                // Output: normalized radius values
                const radii = contour.points.map(p => p.radius / 100); // Normalize
                outputs.push(radii);
            }

            if (inputs.length === 0) return;

            // Build simple model
            const model = tf.sequential();
            model.add(tf.layers.flatten({ inputShape: [64, 64] }));
            model.add(tf.layers.dense({ units: 128, activation: 'relu' }));
            model.add(tf.layers.dense({ units: 64, activation: 'relu' }));
            model.add(tf.layers.dense({ units: outputs[0].length, activation: 'linear' }));

            model.compile({
                optimizer: 'adam',
                loss: 'meanSquaredError'
            });

            const xs = tf.tensor3d(inputs);
            const ys = tf.tensor2d(outputs);

            await model.fit(xs, ys, {
                epochs: epochs,
                batchSize: batchSize,
                callbacks: {
                    onEpochEnd: (epoch, logs) => {
                        updateStatus(`Training epoch ${epoch + 1}/${epochs}, loss: ${logs.loss.toFixed(4)}`);
                    }
                }
            });

            state.trainingData.tfModel = model;
            xs.dispose();
            ys.dispose();
        }

        function extractPatch(grayData, width, height, cx, cy, size) {
            const patch = [];
            const halfSize = size / 2;

            for (let dy = -halfSize; dy < halfSize; dy++) {
                const row = [];
                for (let dx = -halfSize; dx < halfSize; dx++) {
                    const x = Math.min(Math.max(cx + dx, 0), width - 1);
                    const y = Math.min(Math.max(cy + dy, 0), height - 1);
                    row.push(grayData[y * width + x] / 255);
                }
                patch.push(row);
            }
            return patch;
        }

        // ============================================
        // CLUSTERED POINTS CHECK
        // ============================================
        function checkClusteredPoints(boundary, startPoint) {
            if (!boundary || boundary.length === 0) return { clustered: false };

            // Calculate statistics
            const radii = boundary.map(p => p.radius);
            const meanRadius = radii.reduce((a, b) => a + b, 0) / radii.length;
            const maxRadius = Math.max(...radii);
            const minRadius = Math.min(...radii);
            const range = maxRadius - minRadius;

            // Clustered if: mean radius < 15px OR range < 10px (all points very close together)
            const clustered = meanRadius < 15 || range < 10;

            return {
                clustered,
                meanRadius,
                maxRadius,
                minRadius,
                range
            };
        }

        function showClusteredWarning(algorithm) {
            const tips = {
                ray: 'Threshold Factor를 높이거나 시작점을 어두운(trench 내부) 영역으로 이동하세요.',
                canny: 'High Threshold를 낮추세요 (권장: 30-50). Sigma를 높여보세요.',
                adaptive: 'Block Size를 높이세요 (권장: 31-51). Constant C를 낮춰보세요.',
                sobel: 'Gradient Threshold를 낮추세요 (권장: 20-40).',
                statistical: 'Training 데이터의 시작점 위치를 확인하고, Ray 파라미터를 조정하세요.',
                template: 'Training 데이터의 시작점 위치를 확인하고, Ray 파라미터를 조정하세요.',
                neural: 'Training 데이터의 시작점 위치를 확인하고, Ray 파라미터를 조정하세요.'
            };

            const tip = tips[algorithm] || tips.ray;
            alert(`⚠️ 모든 점이 시작점 근처에 모여있습니다!\n\nEdge detection이 제대로 작동하지 않았습니다.\n\n💡 해결 방법:\n${tip}`);
        }

        // ============================================
        // TRAINING PREVIEW DETECTION
        // ============================================
        async function detectTrainingPreview() {
            const trainingImages = state.images.filter(img => img.startPoint && img.mode === 'training');
            if (trainingImages.length === 0) {
                alert('Training 이미지에 시작점을 먼저 설정하세요.');
                return;
            }

            const algorithm = document.getElementById('mainAlgorithm').value;
            const hasModels = state.trainingData.meanProfile || state.trainingData.templates.length > 0;

            if (!hasModels) {
                alert('먼저 모델을 빌드하세요 (Build Models).');
                return;
            }

            const filter = document.getElementById('noiseFilter').value;
            const directionDeg = parseFloat(document.getElementById('directionAngle').value);
            const rangeDeg = parseFloat(document.getElementById('scanRange').value);
            const stepDeg = parseFloat(document.getElementById('angleStep').value);

            updateStatus(`Training 이미지에서 ${algorithm} 모델로 Detection 미리보기 중...`);
            showProgress(true);

            let processed = 0;
            let clusteredCount = 0;

            for (let i = 0; i < state.images.length; i++) {
                const img = state.images[i];
                if (!img.startPoint || img.mode !== 'training') continue;

                // Extract boundary using selected algorithm
                img.boundary = extractBoundary(img, directionDeg, rangeDeg, stepDeg);

                // Check for clustered points
                const clusterCheck = checkClusteredPoints(img.boundary, img.startPoint);
                if (clusterCheck.clustered) {
                    clusteredCount++;
                }

                // Apply shape learning model filtering
                let detectedBoundary = img.boundary;

                if (algorithm === 'statistical' && state.trainingData.meanProfile) {
                    const sigma = parseFloat(document.getElementById('sigmaThreshold').value);
                    detectedBoundary = applyStatisticalFilter(img.boundary, {
                        meanProfile: state.trainingData.meanProfile,
                        stdProfile: state.trainingData.stdProfile,
                        startAngle: state.trainingData.angleConfig.directionDeg - state.trainingData.angleConfig.rangeDeg,
                        stepDeg: state.trainingData.angleConfig.stepDeg
                    }, sigma);
                }

                if (algorithm === 'template' && state.trainingData.templates.length > 0) {
                    const matchResult = matchTemplate(img.boundary, state.trainingData.templates);
                    img.templateScore = matchResult.score;
                }

                // Apply noise filter
                img.filteredBoundary = applyNoiseFilter(detectedBoundary, filter, img);

                redrawCanvas(i);

                const preview = document.getElementById(`preview-${i}`);
                preview.style.display = 'block';
                let previewHtml = `<strong>Algorithm:</strong> ${algorithm} | <strong>Detected:</strong> ${img.boundary.length} points`;
                if (img.filteredBoundary) {
                    previewHtml += ` | <strong>Filtered:</strong> ${img.filteredBoundary.length} points`;
                }
                if (img.templateScore !== undefined) {
                    previewHtml += ` | <strong>Match:</strong> ${(img.templateScore * 100).toFixed(1)}%`;
                }
                if (clusterCheck.clustered) {
                    previewHtml += ` | <span style="color: #ff4444;">⚠️ Clustered (mean: ${clusterCheck.meanRadius.toFixed(1)}px)</span>`;
                }
                preview.innerHTML = previewHtml;

                processed++;
                updateProgress(processed / trainingImages.length * 100);
                await new Promise(resolve => setTimeout(resolve, 0));
            }

            showProgress(false);

            // Show clustered warning if all images have clustered points
            if (clusteredCount > 0 && clusteredCount === processed) {
                showClusteredWarning(algorithm);
            } else if (clusteredCount > 0) {
                updateStatus(`Detection 미리보기 완료. ${processed}개 이미지 처리됨. ⚠️ ${clusteredCount}개 이미지에서 점이 밀집됨.`);
            } else {
                updateStatus(`Detection 미리보기 완료. ${processed}개 이미지 처리됨.`);
            }

            updateButtons();
        }

        // ============================================
        // DETECTION
        // ============================================
        async function detectAll() {
            const detectionImages = state.images.filter(img => img.startPoint && img.mode === 'detection');
            if (detectionImages.length === 0) {
                alert('Load images and set start points first.');
                return;
            }

            const algorithm = document.getElementById('mainAlgorithm').value;
            const isEdgeOnly = ['ray', 'canny', 'adaptive', 'sobel'].includes(algorithm);
            const filter = document.getElementById('noiseFilter').value;
            const directionDeg = parseFloat(document.getElementById('directionAngle').value);
            const rangeDeg = parseFloat(document.getElementById('scanRange').value);
            const stepDeg = parseFloat(document.getElementById('angleStep').value);

            // Check model requirement for Shape Learning algorithms
            if (!isEdgeOnly) {
                const hasModels = state.trainingData.meanProfile || state.trainingData.templates.length > 0;
                if (!hasModels && algorithm !== 'neural') {
                    alert('Shape Learning algorithms require trained models. Please train or load a model first.');
                    return;
                }
            }

            updateStatus(`Detecting boundaries using ${algorithm}...`);
            showProgress(true);

            let processed = 0;
            let clusteredCount = 0;

            for (let i = 0; i < state.images.length; i++) {
                const img = state.images[i];
                if (!img.startPoint || img.mode !== 'detection') continue;

                // Extract boundary using selected algorithm (edge detection method)
                img.boundary = extractBoundary(img, directionDeg, rangeDeg, stepDeg);

                // Check for clustered points
                const clusterCheck = checkClusteredPoints(img.boundary, img.startPoint);
                if (clusterCheck.clustered) {
                    clusteredCount++;
                }

                // For Shape Learning algorithms, apply additional model-based filtering
                let detectedBoundary = img.boundary;

                if (!isEdgeOnly) {
                    // Apply shape learning model filtering
                    if (algorithm === 'statistical' && state.trainingData.meanProfile) {
                        const sigma = parseFloat(document.getElementById('sigmaThreshold').value);
                        detectedBoundary = applyStatisticalFilter(img.boundary, {
                            meanProfile: state.trainingData.meanProfile,
                            stdProfile: state.trainingData.stdProfile,
                            startAngle: state.trainingData.angleConfig.directionDeg - state.trainingData.angleConfig.rangeDeg,
                            stepDeg: state.trainingData.angleConfig.stepDeg
                        }, sigma);
                    }

                    if (algorithm === 'template' && state.trainingData.templates.length > 0) {
                        const matchResult = matchTemplate(img.boundary, state.trainingData.templates);
                        img.templateScore = matchResult.score;
                    }
                }

                // Apply noise filter
                img.filteredBoundary = applyNoiseFilter(detectedBoundary, filter, img);

                redrawCanvas(i);

                const preview = document.getElementById(`preview-${i}`);
                preview.style.display = 'block';
                let previewHtml = `<strong>Algorithm:</strong> ${algorithm} | <strong>Detected:</strong> ${img.boundary.length} points`;
                if (img.filteredBoundary) {
                    previewHtml += ` | <strong>Filtered:</strong> ${img.filteredBoundary.length} points`;
                }
                if (img.templateScore !== undefined) {
                    previewHtml += ` | <strong>Match:</strong> ${(img.templateScore * 100).toFixed(1)}%`;
                }
                if (clusterCheck.clustered) {
                    previewHtml += ` | <span style="color: #ff4444;">⚠️ Clustered (mean: ${clusterCheck.meanRadius.toFixed(1)}px)</span>`;
                }
                preview.innerHTML = previewHtml;

                processed++;
                updateProgress(processed / detectionImages.length * 100);
                await new Promise(resolve => setTimeout(resolve, 0));
            }

            showProgress(false);

            // Show clustered warning if all images have clustered points
            if (clusteredCount > 0 && clusteredCount === processed) {
                showClusteredWarning(algorithm);
            } else if (clusteredCount > 0) {
                updateStatus(`Detection complete. ${processed} images processed. ⚠️ ${clusteredCount} image(s) have clustered points.`);
            } else {
                updateStatus(`Detection complete. ${processed} images processed using ${algorithm}.`);
            }
            updateButtons();
        }

        function applyNoiseFilter(boundary, filterType, img) {
            if (!boundary || boundary.length === 0) return boundary;

            let filtered = boundary;

            if (filterType === 'fft' || filterType === 'all') {
                const cutoff = parseFloat(document.getElementById('fftCutoff').value);
                filtered = fftFilter(filtered, cutoff);
            }

            if (filterType === 'consistency' || filterType === 'all') {
                const maxDeriv = parseFloat(document.getElementById('maxDerivative').value);
                filtered = consistencyFilter(filtered, maxDeriv);
            }

            if (filterType === 'ransac' || filterType === 'all') {
                const iterations = parseInt(document.getElementById('ransacIterations').value);
                const threshold = parseFloat(document.getElementById('ransacThreshold').value);
                const degree = parseInt(document.getElementById('polyDegree').value);
                const result = ransacFit(filtered, iterations, threshold, degree);
                filtered = result.filtered || filtered;
                img.ransacOutliers = result.outliers;
            }

            // Update coordinates based on start point
            if (img.startPoint) {
                filtered = filtered.map(p => ({
                    ...p,
                    x: img.startPoint.x + p.radius * Math.cos(p.angle * Math.PI / 180),
                    y: img.startPoint.y + p.radius * Math.sin(p.angle * Math.PI / 180)
                }));
            }

            return filtered;
        }

        // ============================================
        // EXPORT
        // ============================================
        async function exportResults() {
            const measuredImages = state.images.filter(img => img.filteredBoundary && img.filteredBoundary.length > 0);
            if (measuredImages.length === 0) {
                alert('No detection results to export.');
                return;
            }

            updateStatus('Preparing export...');
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
            const zip = new JSZip();

            // JSON export
            const jsonData = {
                exportDate: new Date().toISOString(),
                settings: {
                    algorithm: document.getElementById('mainAlgorithm').value,
                    noiseFilter: document.getElementById('noiseFilter').value,
                    directionAngle: parseFloat(document.getElementById('directionAngle').value),
                    scanRange: parseFloat(document.getElementById('scanRange').value),
                    angleStep: parseFloat(document.getElementById('angleStep').value)
                },
                images: measuredImages.map(img => ({
                    name: img.name,
                    startPoint: img.startPoint,
                    globalMean: img.globalMean,
                    templateScore: img.templateScore,
                    coordinates: img.filteredBoundary.map(p => ({
                        x: parseFloat((p.x - img.startPoint.x).toFixed(4)),
                        y: parseFloat((p.y - img.startPoint.y).toFixed(4)),
                        intensity: parseFloat(p.intensity.toFixed(4))
                    }))
                }))
            };
            zip.file('bucket_detection.json', JSON.stringify(jsonData, null, 2));

            // XLSX export
            const workbook = XLSX.utils.book_new();

            const summaryData = [
                ['Image', 'Start X', 'Start Y', 'Points', 'Template Score']
            ];
            for (const img of measuredImages) {
                summaryData.push([
                    img.name,
                    img.startPoint.x,
                    img.startPoint.y,
                    img.filteredBoundary.length,
                    img.templateScore?.toFixed(4) || 'N/A'
                ]);
            }
            XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(summaryData), 'Summary');

            for (const img of measuredImages) {
                const sheetName = img.name.slice(0, 28).replace(/[\\\/\*\?\[\]:]/g, '_');
                const data = [['x_cart', 'y_cart', 'intensity']];
                for (const p of img.filteredBoundary) {
                    data.push([
                        (p.x - img.startPoint.x).toFixed(4),
                        (p.y - img.startPoint.y).toFixed(4),
                        p.intensity.toFixed(4)
                    ]);
                }
                XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(data), sheetName);
            }

            zip.file('bucket_detection.xlsx', XLSX.write(workbook, { bookType: 'xlsx', type: 'array' }));

            // Images
            const imagesFolder = zip.folder('images');
            for (const img of state.images) {
                if (!img.filteredBoundary) continue;
                const dataUrl = img.canvas.toDataURL('image/png');
                const base64Data = dataUrl.split(',')[1];
                imagesFolder.file(img.name.replace(/\.[^/.]+$/, '') + '_detected.png', base64Data, { base64: true });
            }

            // Generate ZIP
            const zipBlob = await zip.generateAsync({ type: 'blob' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(zipBlob);
            a.download = `bucket_detection_${timestamp}.zip`;
            a.click();
            URL.revokeObjectURL(a.href);

            updateStatus('Export complete!');
        }

        // ============================================
        // MODEL PERSISTENCE
        // ============================================
        function saveModels() {
            const data = {
                version: 1,
                angleConfig: state.trainingData.angleConfig,
                meanProfile: Array.from(state.trainingData.meanProfile || []),
                stdProfile: Array.from(state.trainingData.stdProfile || []),
                templates: state.trainingData.templates
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'trench_models.json';
            a.click();
            URL.revokeObjectURL(a.href);

            updateStatus('Models saved!');
        }

        function loadModels() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const text = await file.text();
                const data = JSON.parse(text);

                state.trainingData.angleConfig = data.angleConfig;
                state.trainingData.meanProfile = new Float32Array(data.meanProfile);
                state.trainingData.stdProfile = new Float32Array(data.stdProfile);
                state.trainingData.templates = data.templates;
                state.trainingData.modelSource = 'loaded';
                state.trainingData.loadedFileName = file.name;

                if (data.meanProfile.length > 0) {
                    document.getElementById('statModelStatus').className = 'model-indicator ready';
                    document.getElementById('statModelStatus').textContent = 'Statistical: Ready';
                }
                if (data.templates.length > 0) {
                    document.getElementById('templateModelStatus').className = 'model-indicator ready';
                    document.getElementById('templateModelStatus').textContent = `Template: ${data.templates.length} loaded`;
                }

                updateModelSourceDisplay();
                updateStatus('Models loaded!');
                updateButtons();
            };
            input.click();
        }

        // ============================================
        // UI HELPERS
        // ============================================
        function updateStatus(text) {
            document.getElementById('statusText').textContent = text;
        }

        function updateModelSourceDisplay() {
            const el = document.getElementById('modelSourceInfo');
            if (state.trainingData.modelSource === 'built') {
                el.textContent = 'Model: Built from training';
                el.className = 'model-source-info built';
            } else if (state.trainingData.modelSource === 'loaded') {
                el.textContent = `Model: ${state.trainingData.loadedFileName}`;
                el.className = 'model-source-info loaded';
            } else {
                el.textContent = 'Model: None';
                el.className = 'model-source-info none';
            }
        }

        function updateCounts() {
            const mode = state.mode;
            const modeImages = state.images.filter(img => img.mode === mode);
            document.getElementById('imageCount').textContent = modeImages.length;
            document.getElementById('pointCount').textContent = modeImages.filter(img => img.startPoint).length;
            document.getElementById('boundaryCount').textContent = modeImages.filter(img => img.boundary?.length > 0).length;
        }

        function showProgress(show) {
            document.getElementById('progressBarContainer').style.display = show ? 'block' : 'none';
        }

        function updateProgress(percent) {
            document.getElementById('progressBar').style.width = `${percent}%`;
        }

        function updateButtons() {
            const trainingImages = state.images.filter(img => img.mode === 'training');
            const detectionImages = state.images.filter(img => img.mode === 'detection');

            const hasTrainingPoints = trainingImages.some(img => img.startPoint);
            const hasBoundaries = state.trainingData.contours.length > 0;
            const hasModels = state.trainingData.meanProfile || state.trainingData.templates.length > 0;

            document.getElementById('extractBtn').disabled = !hasTrainingPoints;
            document.getElementById('buildModelBtn').disabled = !hasBoundaries;
            document.getElementById('saveModelBtn').disabled = !hasModels;
            document.getElementById('detectTrainingBtn').disabled = !hasModels || !hasTrainingPoints;

            const hasDetectionPoints = detectionImages.some(img => img.startPoint);
            const hasDetectionResults = detectionImages.some(img => img.filteredBoundary?.length > 0);

            // Check if algorithm is Edge Detection only (no model required)
            const algorithm = document.getElementById('mainAlgorithm').value;
            const isEdgeOnly = ['ray', 'canny', 'adaptive', 'sobel'].includes(algorithm);

            // Edge Detection: 모델 없이도 Detect 가능
            // Shape Learning: 모델 필요
            if (isEdgeOnly) {
                document.getElementById('detectBtn').disabled = !hasDetectionPoints;
            } else {
                document.getElementById('detectBtn').disabled = !hasDetectionPoints || !hasModels;
            }
            document.getElementById('exportBtn').disabled = !hasDetectionResults;
        }

        function clearAll() {
            if (state.images.length > 0 && !confirm('Clear all data?')) return;

            state.images = [];
            state.trainingData = {
                contours: [],
                meanProfile: null,
                stdProfile: null,
                templates: [],
                tfModel: null,
                angleConfig: null,
                modelSource: null,
                loadedFileName: null
            };

            document.getElementById('imageGrid').innerHTML = '';
            document.getElementById('statModelStatus').className = 'model-indicator not-ready';
            document.getElementById('statModelStatus').textContent = 'Statistical: Not Ready';
            document.getElementById('templateModelStatus').className = 'model-indicator not-ready';
            document.getElementById('templateModelStatus').textContent = 'Template: Not Ready';
            document.getElementById('neuralModelStatus').className = 'model-indicator not-ready';
            document.getElementById('neuralModelStatus').textContent = 'Neural: Not Ready';

            updateModelSourceDisplay();
            updateCounts();
            updateStatus('Cleared.');
            updateButtons();
        }

        function clearDetection() {
            state.images = state.images.filter(img => img.mode === 'training');
            document.getElementById('imageGrid').innerHTML = '';

            // Re-render training images
            state.images.forEach((img, i) => {
                const grid = document.getElementById('imageGrid');
                const card = document.createElement('div');
                card.className = 'image-card';
                card.id = `card-${i}`;
                card.innerHTML = `
                    <h3>${img.name}</h3>
                    <div class="canvas-container">
                        <canvas id="canvas-${i}"></canvas>
                    </div>
                    <div class="coord-info">
                        Start Point: <span id="coord-${i}">${img.startPoint ? `(${img.startPoint.x}, ${img.startPoint.y})` : 'Not set'}</span>
                    </div>
                `;
                grid.appendChild(card);

                const canvas = document.getElementById(`canvas-${i}`);
                img.canvas = canvas;
                img.ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                redrawCanvas(i);
                canvas.addEventListener('click', (e) => handleCanvasClick(e, i));
            });

            updateCounts();
            updateStatus('Detection cleared.');
            updateButtons();
        }

        // ============================================
        // PARAMETER CHANGE LISTENERS (AUTO RE-DETECT)
        // ============================================
        function setupParameterListeners() {
            const params = [
                'directionAngle', 'scanRange', 'angleStep',
                'sigmaThreshold', 'matchThreshold',
                'fftCutoff', 'maxDerivative',
                'ransacIterations', 'ransacThreshold', 'polyDegree',
                // Algorithm-specific params
                'mainAlgorithm', 'rayThreshold',
                'cannySigma', 'cannyLow', 'cannyHigh',
                'adaptiveBlock', 'adaptiveC',
                'sobelThreshold'
            ];

            params.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('change', () => {
                        const hasResults = state.images.some(
                            img => img.mode === 'detection' && img.filteredBoundary?.length > 0
                        );
                        if (hasResults) {
                            detectAll();
                        }
                    });
                }
            });
        }

        // ============================================
        // ALGORITHM UI TOGGLE
        // ============================================
        function updateAlgorithmUI() {
            const algorithm = document.getElementById('mainAlgorithm').value;
            const isEdgeOnly = ['ray', 'canny', 'adaptive', 'sobel'].includes(algorithm);

            // Update description
            const descEl = document.getElementById('algorithmDescription');
            if (isEdgeOnly) {
                descEl.textContent = '이미지 처리만으로 boundary 추출 (Training 불필요)';
            } else {
                descEl.textContent = '학습 데이터로 모델 생성 후 Detection (Training 필요)';
            }

            // Toggle mode tabs visibility
            const modeTabs = document.getElementById('modeTabs');
            const tabTraining = document.getElementById('tabTraining');
            if (isEdgeOnly) {
                // Edge Detection: Hide training tab, switch to detection
                tabTraining.style.display = 'none';
                switchMode('detection');
            } else {
                // Shape Learning: Show both tabs
                tabTraining.style.display = '';
            }

            // Toggle model status visibility
            const modelStatus = document.querySelector('.model-status');
            const modelSourceInfo = document.getElementById('modelSourceInfo');
            if (isEdgeOnly) {
                modelStatus.style.display = 'none';
                modelSourceInfo.style.display = 'none';
            } else {
                modelStatus.style.display = '';
                modelSourceInfo.style.display = '';
            }

            // Hide all algorithm settings
            const allSettings = [
                'raySettings', 'cannyEdgeSettings', 'adaptiveEdgeSettings', 'sobelEdgeSettings',
                'statisticalAlgoSettings', 'templateAlgoSettings', 'neuralAlgoSettings'
            ];
            allSettings.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.classList.add('hidden');
            });

            // Show selected algorithm settings
            switch (algorithm) {
                case 'ray':
                    document.getElementById('raySettings').classList.remove('hidden');
                    break;
                case 'canny':
                    document.getElementById('cannyEdgeSettings').classList.remove('hidden');
                    break;
                case 'adaptive':
                    document.getElementById('adaptiveEdgeSettings').classList.remove('hidden');
                    break;
                case 'sobel':
                    document.getElementById('sobelEdgeSettings').classList.remove('hidden');
                    break;
                case 'statistical':
                    document.getElementById('statisticalAlgoSettings').classList.remove('hidden');
                    break;
                case 'template':
                    document.getElementById('templateAlgoSettings').classList.remove('hidden');
                    break;
                case 'neural':
                    document.getElementById('neuralAlgoSettings').classList.remove('hidden');
                    break;
            }

            // Update buttons based on new algorithm
            updateButtons();
        }

        // Initialize on page load
        setupParameterListeners();
        updateAlgorithmUI();
    </script>
</body>
</html>
