<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Batch Image Measurement Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #00d9ff;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        .btn-primary {
            background: #00d9ff;
            color: #1a1a2e;
        }
        .btn-primary:hover {
            background: #00b8d9;
        }
        .btn-success {
            background: #00ff88;
            color: #1a1a2e;
        }
        .btn-success:hover {
            background: #00cc6a;
        }
        .btn-warning {
            background: #ffaa00;
            color: #1a1a2e;
        }
        .btn-warning:hover {
            background: #dd9500;
        }
        .btn-danger {
            background: #ff4444;
            color: white;
        }
        .btn-danger:hover {
            background: #cc3333;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #fileInput {
            display: none;
        }
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .image-card {
            background: #16213e;
            border-radius: 10px;
            padding: 15px;
            position: relative;
        }
        .image-card.selected {
            border: 3px solid #00d9ff;
        }
        .image-card h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #00d9ff;
            word-break: break-all;
        }
        .canvas-container {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        .canvas-container canvas {
            max-width: 100%;
            height: auto;
            cursor: crosshair;
            border-radius: 5px;
        }
        .coord-info {
            margin-top: 10px;
            font-size: 12px;
            color: #aaa;
        }
        .coord-info span {
            color: #00ff88;
        }
        .status-bar {
            background: #16213e;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .status-bar p {
            margin: 5px 0;
        }
        .settings-panel {
            background: #16213e;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .settings-panel h3 {
            margin-bottom: 15px;
            color: #00d9ff;
        }
        .setting-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .setting-row label {
            min-width: 150px;
        }
        .setting-row input {
            padding: 5px 10px;
            border: 1px solid #333;
            border-radius: 5px;
            background: #1a1a2e;
            color: #eee;
            width: 100px;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            transition: width 0.3s;
        }
        .help-text {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        .measurement-preview {
            margin-top: 10px;
            padding: 10px;
            background: #1a1a2e;
            border-radius: 5px;
            font-size: 11px;
        }
        .template-size-info {
            display: inline-block;
            margin-left: 10px;
            padding: 2px 8px;
            background: #333;
            border-radius: 3px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Batch Image Measurement Tool</h1>

        <div class="status-bar">
            <p><strong>Status:</strong> <span id="statusText">Ready - Upload images to begin</span></p>
            <p><strong>Images Loaded:</strong> <span id="imageCount">0</span> |
               <strong>With Start Points:</strong> <span id="pointCount">0</span> |
               <strong>Measured:</strong> <span id="measuredCount">0</span></p>
            <div class="progress-bar" id="progressBarContainer" style="display: none;">
                <div class="progress-bar-fill" id="progressBar" style="width: 0%"></div>
            </div>
        </div>

        <div class="controls">
            <input type="file" id="fileInput" multiple accept="image/*">
            <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                1. Upload Images
            </button>
            <button class="btn btn-warning" id="propagateBtn" onclick="propagateStartPoint()" disabled>
                2. Propagate Start Point
            </button>
            <button class="btn btn-success" id="measureBtn" onclick="measureAll()" disabled>
                3. Measure All
            </button>
            <button class="btn btn-primary" id="exportBtn" onclick="exportAll()" disabled>
                4. Export All (ZIP)
            </button>
            <button class="btn btn-danger" onclick="clearAll()">
                Clear All
            </button>
        </div>

        <div class="settings-panel">
            <h3>Settings</h3>
            <div class="setting-row">
                <label>Angle Start (deg):</label>
                <input type="number" id="angleStart" value="0" min="0" max="359">
            </div>
            <div class="setting-row">
                <label>Angle End (deg):</label>
                <input type="number" id="angleEnd" value="180" min="1" max="360">
            </div>
            <div class="setting-row">
                <label>Angle Step (deg):</label>
                <input type="number" id="angleStep" value="1" min="0.1" max="10" step="0.1">
            </div>
            <div class="setting-row">
                <label>Template Size (px):</label>
                <input type="number" id="templateSize" value="41" min="11" max="101" step="2">
                <span class="template-size-info">Used for propagation matching</span>
            </div>
            <div class="setting-row">
                <label>Detection Mode:</label>
                <select id="detectionMode" style="padding: 5px 10px; border: 1px solid #333; border-radius: 5px; background: #1a1a2e; color: #eee; width: 180px;">
                    <option value="ray">Ray (Threshold)</option>
                    <option value="canny">Canny Edge Detection</option>
                    <option value="adaptive">Adaptive Threshold</option>
                </select>
            </div>

            <!-- Ray Settings -->
            <div id="raySettings">
                <div class="setting-row">
                    <label>Ray Threshold:</label>
                    <input type="number" id="rayThreshold" value="1.00" min="0.01" max="5.00" step="0.01">
                    <span class="template-size-info">Stop when intensity > mean Ã— threshold (default: 1.00)</span>
                </div>
            </div>

            <!-- Canny Settings -->
            <div id="cannySettings" style="display: none;">
                <div class="setting-row">
                    <label>Gaussian Sigma:</label>
                    <input type="number" id="gaussianSigma" value="1.4" min="0.5" max="5.0" step="0.1">
                    <span class="template-size-info">Blur strength (1.0-2.0 typical)</span>
                </div>
                <div class="setting-row">
                    <label>Low Threshold:</label>
                    <input type="number" id="cannyLowThreshold" value="20" min="1" max="100">
                    <span class="template-size-info">Weak edge threshold</span>
                </div>
                <div class="setting-row">
                    <label>High Threshold:</label>
                    <input type="number" id="cannyHighThreshold" value="50" min="1" max="255">
                    <span class="template-size-info">Strong edge threshold</span>
                </div>
            </div>

            <!-- Adaptive Settings -->
            <div id="adaptiveSettings" style="display: none;">
                <div class="setting-row">
                    <label>Block Size (px):</label>
                    <input type="number" id="adaptiveBlockSize" value="31" min="3" max="101" step="2">
                    <span class="template-size-info">Must be odd (21-51 recommended)</span>
                </div>
                <div class="setting-row">
                    <label>Threshold Constant (C):</label>
                    <input type="number" id="adaptiveC" value="10" min="-50" max="50" step="1">
                    <span class="template-size-info">Higher = more sensitive to edges</span>
                </div>
            </div>

            <!-- Common Options -->
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #333;">
                <div class="setting-row">
                    <label><input type="checkbox" id="showEdgeOverlay" style="width: auto; margin-right: 5px;"> Show Edge Map Overlay</label>
                    <span class="template-size-info">Visualize detected edges (Canny/Adaptive only)</span>
                </div>
                <div class="setting-row">
                    <label><input type="checkbox" id="enableSmoothing" style="width: auto; margin-right: 5px;"> Enable Result Smoothing</label>
                    <span class="template-size-info">Median filter to reduce outliers</span>
                </div>
                <div class="setting-row" id="smoothingWindowRow" style="display: none;">
                    <label>Smoothing Window:</label>
                    <input type="number" id="smoothingWindow" value="5" min="3" max="21" step="2">
                    <span class="template-size-info">Odd number (3-21)</span>
                </div>
            </div>

            <p class="help-text">
                Click on an image to set the measurement start point.
                Then click "Propagate" to find similar points in other images.
            </p>
        </div>

        <div class="image-grid" id="imageGrid"></div>
    </div>

    <script>
        // Global state
        const state = {
            images: [],  // {name, element, canvas, ctx, grayData, startPoint, results}
            sourceIndex: null,  // index of image used for propagation
            measured: false
        };

        // File input handler
        document.getElementById('fileInput').addEventListener('change', handleFileUpload);

        // Ray threshold change handler - re-measure when threshold changes
        document.getElementById('rayThreshold').addEventListener('change', function() {
            if (state.measured && state.images.some(img => img.startPoint)) {
                measureAll();
            }
        });

        // Detection mode change handler
        document.getElementById('detectionMode').addEventListener('change', function() {
            const mode = this.value;
            document.getElementById('raySettings').style.display = mode === 'ray' ? 'block' : 'none';
            document.getElementById('cannySettings').style.display = mode === 'canny' ? 'block' : 'none';
            document.getElementById('adaptiveSettings').style.display = mode === 'adaptive' ? 'block' : 'none';

            if (state.measured && state.images.some(img => img.startPoint)) {
                measureAll();
            }
        });

        // Canny/Adaptive parameter change handlers
        ['gaussianSigma', 'cannyLowThreshold', 'cannyHighThreshold', 'adaptiveBlockSize', 'adaptiveC'].forEach(id => {
            document.getElementById(id).addEventListener('change', function() {
                if (state.measured && state.images.some(img => img.startPoint)) {
                    measureAll();
                }
            });
        });

        // Edge overlay toggle handler
        document.getElementById('showEdgeOverlay').addEventListener('change', function() {
            state.images.forEach((img, i) => {
                if (img.startPoint) redrawCanvas(i);
            });
        });

        // Smoothing toggle handler
        document.getElementById('enableSmoothing').addEventListener('change', function() {
            document.getElementById('smoothingWindowRow').style.display = this.checked ? 'flex' : 'none';
            if (state.measured && state.images.some(img => img.startPoint)) {
                measureAll();
            }
        });

        // Smoothing window change handler
        document.getElementById('smoothingWindow').addEventListener('change', function() {
            if (state.measured && state.images.some(img => img.startPoint)) {
                measureAll();
            }
        });

        async function handleFileUpload(e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            updateStatus('Loading images...');
            const grid = document.getElementById('imageGrid');

            for (const file of files) {
                const img = await loadImage(file);
                const index = state.images.length;

                // Create card
                const card = document.createElement('div');
                card.className = 'image-card';
                card.id = `card-${index}`;
                card.innerHTML = `
                    <h3>${file.name}</h3>
                    <div class="canvas-container">
                        <canvas id="canvas-${index}"></canvas>
                    </div>
                    <div class="coord-info">
                        Start Point: <span id="coord-${index}">Not set</span>
                    </div>
                    <div class="measurement-preview" id="preview-${index}" style="display:none;"></div>
                `;
                grid.appendChild(card);

                // Setup canvas
                const canvas = document.getElementById(`canvas-${index}`);
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);

                // Get grayscale data
                const imageData = ctx.getImageData(0, 0, img.width, img.height);
                const grayData = toGrayscale(imageData);

                // Store state
                state.images.push({
                    name: file.name,
                    element: img,
                    canvas: canvas,
                    ctx: ctx,
                    grayData: grayData,
                    width: img.width,
                    height: img.height,
                    startPoint: null,
                    results: null,
                    globalMean: calculateGlobalMean(grayData)
                });

                // Add click handler
                canvas.addEventListener('click', (e) => handleCanvasClick(e, index));
            }

            updateCounts();
            updateStatus('Images loaded. Click on an image to set start point.');
            e.target.value = '';  // Reset input
        }

        function loadImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function toGrayscale(imageData) {
            const data = imageData.data;
            const gray = new Float32Array(imageData.width * imageData.height);
            for (let i = 0; i < gray.length; i++) {
                const idx = i * 4;
                // ITU-R BT.601 formula
                gray[i] = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
            }
            return gray;
        }

        function calculateGlobalMean(grayData) {
            let sum = 0;
            for (let i = 0; i < grayData.length; i++) {
                sum += grayData[i];
            }
            return sum / grayData.length;
        }

        function handleCanvasClick(e, index) {
            const canvas = state.images[index].canvas;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.round((e.clientX - rect.left) * scaleX);
            const y = Math.round((e.clientY - rect.top) * scaleY);

            setStartPoint(index, x, y);
            state.sourceIndex = index;

            // Highlight selected card
            document.querySelectorAll('.image-card').forEach(c => c.classList.remove('selected'));
            document.getElementById(`card-${index}`).classList.add('selected');

            updateStatus(`Start point set at (${x}, ${y}) on "${state.images[index].name}". Click "Propagate" to apply to other images.`);
            updateButtons();
        }

        function setStartPoint(index, x, y) {
            const img = state.images[index];
            img.startPoint = { x, y };

            // Redraw canvas
            redrawCanvas(index);

            // Update coordinate display
            document.getElementById(`coord-${index}`).textContent = `(${x}, ${y})`;
            updateCounts();
        }

        function redrawCanvas(index) {
            const img = state.images[index];
            const ctx = img.ctx;

            // Clear and redraw image
            ctx.drawImage(img.element, 0, 0);

            // Draw edge overlay if enabled and available
            const showEdgeOverlay = document.getElementById('showEdgeOverlay').checked;
            if (showEdgeOverlay && img.edgeMap) {
                drawEdgeOverlay(ctx, img.edgeMap, img.width, img.height);
            }

            // Draw start point if exists
            if (img.startPoint) {
                ctx.beginPath();
                ctx.arc(img.startPoint.x, img.startPoint.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw crosshair
                ctx.beginPath();
                ctx.moveTo(img.startPoint.x - 15, img.startPoint.y);
                ctx.lineTo(img.startPoint.x + 15, img.startPoint.y);
                ctx.moveTo(img.startPoint.x, img.startPoint.y - 15);
                ctx.lineTo(img.startPoint.x, img.startPoint.y + 15);
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Draw measurement results if exists
            if (img.results && img.results.length > 0) {
                ctx.fillStyle = 'rgba(255, 165, 0, 0.6)';
                ctx.strokeStyle = 'rgba(255, 165, 0, 0.3)';
                ctx.lineWidth = 1;

                for (const r of img.results) {
                    // Draw ray line
                    ctx.beginPath();
                    ctx.moveTo(img.startPoint.x, img.startPoint.y);
                    ctx.lineTo(r.x, r.y);
                    ctx.stroke();

                    // Draw detection point
                    ctx.beginPath();
                    ctx.arc(r.x, r.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function propagateStartPoint() {
            if (state.sourceIndex === null) {
                alert('Please set a start point on one image first.');
                return;
            }

            const source = state.images[state.sourceIndex];
            if (!source.startPoint) {
                alert('Source image has no start point.');
                return;
            }

            updateStatus('Propagating start point to other images...');
            const templateSize = parseInt(document.getElementById('templateSize').value);

            // Extract template from source image
            const template = extractTemplate(source, source.startPoint.x, source.startPoint.y, templateSize);

            let propagated = 0;
            for (let i = 0; i < state.images.length; i++) {
                if (i === state.sourceIndex) continue;

                const target = state.images[i];
                const match = findBestMatch(target, template, templateSize);

                if (match) {
                    setStartPoint(i, match.x, match.y);
                    propagated++;
                }
            }

            updateStatus(`Propagated start point to ${propagated} images. Review and adjust if needed.`);
            updateButtons();
        }

        function extractTemplate(img, cx, cy, size) {
            const halfSize = Math.floor(size / 2);
            const template = [];

            for (let dy = -halfSize; dy <= halfSize; dy++) {
                const row = [];
                for (let dx = -halfSize; dx <= halfSize; dx++) {
                    const x = cx + dx;
                    const y = cy + dy;
                    if (x >= 0 && x < img.width && y >= 0 && y < img.height) {
                        row.push(img.grayData[y * img.width + x]);
                    } else {
                        row.push(0);
                    }
                }
                template.push(row);
            }
            return template;
        }

        function findBestMatch(img, template, templateSize) {
            const halfSize = Math.floor(templateSize / 2);
            let bestScore = -Infinity;
            let bestX = 0, bestY = 0;

            // Search step for performance
            const step = Math.max(1, Math.floor(Math.min(img.width, img.height) / 100));

            // First pass: coarse search
            for (let y = halfSize; y < img.height - halfSize; y += step) {
                for (let x = halfSize; x < img.width - halfSize; x += step) {
                    const score = calculateNCC(img, template, x, y, halfSize);
                    if (score > bestScore) {
                        bestScore = score;
                        bestX = x;
                        bestY = y;
                    }
                }
            }

            // Second pass: fine search around best match
            let refinedX = bestX, refinedY = bestY;
            let refinedScore = bestScore;

            for (let dy = -step; dy <= step; dy++) {
                for (let dx = -step; dx <= step; dx++) {
                    const x = bestX + dx;
                    const y = bestY + dy;
                    if (x < halfSize || x >= img.width - halfSize ||
                        y < halfSize || y >= img.height - halfSize) continue;

                    const score = calculateNCC(img, template, x, y, halfSize);
                    if (score > refinedScore) {
                        refinedScore = score;
                        refinedX = x;
                        refinedY = y;
                    }
                }
            }

            return { x: refinedX, y: refinedY, score: refinedScore };
        }

        function calculateNCC(img, template, cx, cy, halfSize) {
            // Normalized Cross-Correlation
            let sumT = 0, sumI = 0, sumTT = 0, sumII = 0, sumTI = 0;
            let count = 0;

            for (let dy = -halfSize; dy <= halfSize; dy++) {
                for (let dx = -halfSize; dx <= halfSize; dx++) {
                    const tx = dx + halfSize;
                    const ty = dy + halfSize;
                    const t = template[ty][tx];
                    const i = img.grayData[(cy + dy) * img.width + (cx + dx)];

                    sumT += t;
                    sumI += i;
                    sumTT += t * t;
                    sumII += i * i;
                    sumTI += t * i;
                    count++;
                }
            }

            const meanT = sumT / count;
            const meanI = sumI / count;
            const varT = sumTT / count - meanT * meanT;
            const varI = sumII / count - meanI * meanI;
            const covar = sumTI / count - meanT * meanI;

            if (varT <= 0 || varI <= 0) return 0;
            return covar / (Math.sqrt(varT) * Math.sqrt(varI));
        }

        async function measureAll() {
            const imagesWithPoints = state.images.filter(img => img.startPoint);
            if (imagesWithPoints.length === 0) {
                alert('No images have start points set.');
                return;
            }

            const angleStart = parseFloat(document.getElementById('angleStart').value);
            const angleEnd = parseFloat(document.getElementById('angleEnd').value);
            const angleStep = parseFloat(document.getElementById('angleStep').value);
            const detectionMode = document.getElementById('detectionMode').value;

            // Mode-specific settings
            const rayThreshold = parseFloat(document.getElementById('rayThreshold').value);
            const gaussianSigma = parseFloat(document.getElementById('gaussianSigma').value);
            const cannyLowThreshold = parseFloat(document.getElementById('cannyLowThreshold').value);
            const cannyHighThreshold = parseFloat(document.getElementById('cannyHighThreshold').value);
            const adaptiveBlockSize = parseInt(document.getElementById('adaptiveBlockSize').value);
            const adaptiveC = parseFloat(document.getElementById('adaptiveC').value);

            // Smoothing settings
            const enableSmoothing = document.getElementById('enableSmoothing').checked;
            const smoothingWindow = parseInt(document.getElementById('smoothingWindow').value);

            updateStatus(`Measuring with ${detectionMode} mode...`);
            document.getElementById('progressBarContainer').style.display = 'block';

            let measured = 0;
            for (let i = 0; i < state.images.length; i++) {
                const img = state.images[i];
                if (!img.startPoint) continue;

                // Clear previous edge map
                img.edgeMap = null;

                // Perform detection based on mode
                let results;
                switch (detectionMode) {
                    case 'ray':
                        results = performRaycast(img, angleStart, angleEnd, angleStep, rayThreshold);
                        break;
                    case 'canny':
                        results = performCannyDetection(img, angleStart, angleEnd, angleStep,
                            gaussianSigma, cannyLowThreshold, cannyHighThreshold);
                        break;
                    case 'adaptive':
                        results = performAdaptiveDetection(img, angleStart, angleEnd, angleStep,
                            adaptiveBlockSize, adaptiveC);
                        break;
                    default:
                        results = performRaycast(img, angleStart, angleEnd, angleStep, rayThreshold);
                }

                // Apply smoothing if enabled
                if (enableSmoothing && results.length >= smoothingWindow) {
                    results = smoothContourResults(results, img.startPoint.x, img.startPoint.y, smoothingWindow);
                }

                img.results = results;
                img.detectionMode = detectionMode; // Store which mode was used
                redrawCanvas(i);

                // Update preview
                const preview = document.getElementById(`preview-${i}`);
                preview.style.display = 'block';
                const modeLabel = detectionMode.charAt(0).toUpperCase() + detectionMode.slice(1);
                preview.innerHTML = `<strong>Mode:</strong> ${modeLabel} |
                    <strong>Measured:</strong> ${img.results.length} points |
                    <strong>Mean brightness:</strong> ${img.globalMean.toFixed(2)}`;

                measured++;
                const progress = (measured / imagesWithPoints.length) * 100;
                document.getElementById('progressBar').style.width = `${progress}%`;

                // Yield to UI for responsiveness
                await new Promise(resolve => setTimeout(resolve, 0));
            }

            state.measured = true;
            state.detectionMode = detectionMode; // Store current mode in state
            document.getElementById('progressBarContainer').style.display = 'none';
            updateStatus(`Measurement complete. ${measured} images processed using ${detectionMode} mode.`);
            updateCounts();
            updateButtons();
        }

        function performRaycast(img, angleStart, angleEnd, angleStep, threshold) {
            const results = [];
            const { startPoint, grayData, width, height, globalMean } = img;
            const thresholdValue = globalMean * threshold;
            const maxRadius = Math.ceil(Math.hypot(
                Math.max(startPoint.x, width - startPoint.x),
                Math.max(startPoint.y, height - startPoint.y)
            ));

            for (let angle = angleStart; angle <= angleEnd; angle += angleStep) {
                const rad = angle * Math.PI / 180;
                const dx = Math.cos(rad);
                const dy = Math.sin(rad);

                for (let r = 1; r < maxRadius; r++) {
                    const x = startPoint.x + r * dx;
                    const y = startPoint.y + r * dy;

                    if (x < 0 || x >= width || y < 0 || y >= height) break;

                    // Bilinear interpolation
                    const intensity = bilinearSample(grayData, width, height, x, y);

                    if (intensity > thresholdValue) {
                        results.push({
                            angle_deg: angle,
                            r_pixels: r,
                            x: x,
                            y: y,
                            value: intensity
                        });
                        break;
                    }
                }
            }

            return results;
        }

        function bilinearSample(grayData, width, height, x, y) {
            const x0 = Math.floor(x);
            const y0 = Math.floor(y);
            const x1 = Math.min(x0 + 1, width - 1);
            const y1 = Math.min(y0 + 1, height - 1);
            const wx = x - x0;
            const wy = y - y0;

            const i00 = grayData[y0 * width + x0];
            const i10 = grayData[y0 * width + x1];
            const i01 = grayData[y1 * width + x0];
            const i11 = grayData[y1 * width + x1];

            return (1 - wx) * (1 - wy) * i00 +
                   wx * (1 - wy) * i10 +
                   (1 - wx) * wy * i01 +
                   wx * wy * i11;
        }

        // ============================================
        // CANNY EDGE DETECTION ALGORITHM
        // ============================================

        function generateGaussianKernel(sigma) {
            let size = Math.ceil(sigma * 6) | 1;
            if (size < 3) size = 3;

            const kernel = [];
            const center = Math.floor(size / 2);
            let sum = 0;

            for (let y = 0; y < size; y++) {
                const row = [];
                for (let x = 0; x < size; x++) {
                    const dx = x - center;
                    const dy = y - center;
                    const value = Math.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));
                    row.push(value);
                    sum += value;
                }
                kernel.push(row);
            }

            // Normalize
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    kernel[y][x] /= sum;
                }
            }
            return kernel;
        }

        function applyGaussianBlur(grayData, width, height, sigma) {
            const kernel = generateGaussianKernel(sigma);
            const kSize = kernel.length;
            const kHalf = Math.floor(kSize / 2);
            const result = new Float32Array(width * height);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let sum = 0;
                    let weightSum = 0;

                    for (let ky = 0; ky < kSize; ky++) {
                        for (let kx = 0; kx < kSize; kx++) {
                            const px = x + kx - kHalf;
                            const py = y + ky - kHalf;

                            if (px >= 0 && px < width && py >= 0 && py < height) {
                                const weight = kernel[ky][kx];
                                sum += grayData[py * width + px] * weight;
                                weightSum += weight;
                            }
                        }
                    }
                    result[y * width + x] = sum / weightSum;
                }
            }
            return result;
        }

        function computeGradients(blurredData, width, height) {
            const sobelX = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
            const sobelY = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];

            const gradientMagnitude = new Float32Array(width * height);
            const gradientDirection = new Float32Array(width * height);

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;

                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const pixel = blurredData[(y + ky) * width + (x + kx)];
                            gx += pixel * sobelX[ky + 1][kx + 1];
                            gy += pixel * sobelY[ky + 1][kx + 1];
                        }
                    }

                    const idx = y * width + x;
                    gradientMagnitude[idx] = Math.sqrt(gx * gx + gy * gy);
                    gradientDirection[idx] = Math.atan2(gy, gx);
                }
            }
            return { gradientMagnitude, gradientDirection };
        }

        function nonMaximumSuppression(gradientMagnitude, gradientDirection, width, height) {
            const result = new Float32Array(width * height);

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    const magnitude = gradientMagnitude[idx];
                    if (magnitude === 0) continue;

                    let angle = gradientDirection[idx] * 180 / Math.PI;
                    if (angle < 0) angle += 180;

                    let neighbor1, neighbor2;

                    if ((angle >= 0 && angle < 22.5) || (angle >= 157.5 && angle <= 180)) {
                        neighbor1 = gradientMagnitude[y * width + (x - 1)];
                        neighbor2 = gradientMagnitude[y * width + (x + 1)];
                    } else if (angle >= 22.5 && angle < 67.5) {
                        neighbor1 = gradientMagnitude[(y - 1) * width + (x + 1)];
                        neighbor2 = gradientMagnitude[(y + 1) * width + (x - 1)];
                    } else if (angle >= 67.5 && angle < 112.5) {
                        neighbor1 = gradientMagnitude[(y - 1) * width + x];
                        neighbor2 = gradientMagnitude[(y + 1) * width + x];
                    } else {
                        neighbor1 = gradientMagnitude[(y - 1) * width + (x - 1)];
                        neighbor2 = gradientMagnitude[(y + 1) * width + (x + 1)];
                    }

                    if (magnitude >= neighbor1 && magnitude >= neighbor2) {
                        result[idx] = magnitude;
                    }
                }
            }
            return result;
        }

        function hysteresisThreshold(suppressedData, width, height, lowThreshold, highThreshold) {
            const edges = new Uint8Array(width * height);
            const WEAK = 128;
            const STRONG = 255;

            // First pass: classify pixels
            for (let i = 0; i < suppressedData.length; i++) {
                if (suppressedData[i] >= highThreshold) {
                    edges[i] = STRONG;
                } else if (suppressedData[i] >= lowThreshold) {
                    edges[i] = WEAK;
                }
            }

            // Second pass: connect weak edges to strong using BFS
            const queue = [];
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    if (edges[y * width + x] === STRONG) {
                        queue.push({ x, y });
                    }
                }
            }

            while (queue.length > 0) {
                const { x, y } = queue.shift();
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const nIdx = ny * width + nx;
                            if (edges[nIdx] === WEAK) {
                                edges[nIdx] = STRONG;
                                queue.push({ x: nx, y: ny });
                            }
                        }
                    }
                }
            }

            // Remove remaining weak edges
            for (let i = 0; i < edges.length; i++) {
                if (edges[i] !== STRONG) edges[i] = 0;
            }
            return edges;
        }

        function performCannyEdgeDetection(grayData, width, height, sigma, lowThreshold, highThreshold) {
            const blurred = applyGaussianBlur(grayData, width, height, sigma);
            const { gradientMagnitude, gradientDirection } = computeGradients(blurred, width, height);
            const suppressed = nonMaximumSuppression(gradientMagnitude, gradientDirection, width, height);
            const edges = hysteresisThreshold(suppressed, width, height, lowThreshold, highThreshold);
            return edges;
        }

        function findFirstEdgeAlongRay(edgeMap, grayData, width, height, startX, startY, angle, maxRadius) {
            const rad = angle * Math.PI / 180;
            const dx = Math.cos(rad);
            const dy = Math.sin(rad);

            for (let r = 1; r < maxRadius; r++) {
                const x = Math.round(startX + r * dx);
                const y = Math.round(startY + r * dy);

                if (x < 1 || x >= width - 1 || y < 1 || y >= height - 1) break;

                const idx = y * width + x;
                if (edgeMap[idx] === 255) {
                    // Verify dark-to-bright transition
                    const checkDist = 3;
                    const beforeR = r - checkDist;
                    const afterR = r + checkDist;

                    if (beforeR > 0 && afterR < maxRadius) {
                        const beforeX = Math.round(startX + beforeR * dx);
                        const beforeY = Math.round(startY + beforeR * dy);
                        const afterX = Math.round(startX + afterR * dx);
                        const afterY = Math.round(startY + afterR * dy);

                        if (beforeX >= 0 && beforeX < width && beforeY >= 0 && beforeY < height &&
                            afterX >= 0 && afterX < width && afterY >= 0 && afterY < height) {
                            const intensityBefore = grayData[beforeY * width + beforeX];
                            const intensityAfter = grayData[afterY * width + afterX];

                            // We want dark-to-bright transition
                            if (intensityAfter > intensityBefore) {
                                return {
                                    r_pixels: r,
                                    x: startX + r * dx,
                                    y: startY + r * dy,
                                    value: grayData[idx]
                                };
                            }
                            continue; // Skip bright-to-dark transitions
                        }
                    }

                    // Fallback: accept first edge if can't verify
                    return {
                        r_pixels: r,
                        x: startX + r * dx,
                        y: startY + r * dy,
                        value: grayData[idx]
                    };
                }
            }
            return null;
        }

        function performCannyDetection(img, angleStart, angleEnd, angleStep, sigma, lowThreshold, highThreshold) {
            const results = [];
            const { startPoint, grayData, width, height } = img;

            const edgeMap = performCannyEdgeDetection(grayData, width, height, sigma, lowThreshold, highThreshold);
            img.edgeMap = edgeMap; // Cache for visualization

            const maxRadius = Math.ceil(Math.hypot(
                Math.max(startPoint.x, width - startPoint.x),
                Math.max(startPoint.y, height - startPoint.y)
            ));

            for (let angle = angleStart; angle <= angleEnd; angle += angleStep) {
                const edgePoint = findFirstEdgeAlongRay(
                    edgeMap, grayData, width, height,
                    startPoint.x, startPoint.y, angle, maxRadius
                );

                if (edgePoint) {
                    results.push({
                        angle_deg: angle,
                        r_pixels: edgePoint.r_pixels,
                        x: edgePoint.x,
                        y: edgePoint.y,
                        value: edgePoint.value
                    });
                }
            }
            return results;
        }

        // ============================================
        // ADAPTIVE THRESHOLD ALGORITHM
        // ============================================

        function computeIntegralImage(grayData, width, height) {
            const integral = new Float64Array(width * height);

            for (let y = 0; y < height; y++) {
                let rowSum = 0;
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    rowSum += grayData[idx];
                    integral[idx] = rowSum + (y > 0 ? integral[(y - 1) * width + x] : 0);
                }
            }
            return integral;
        }

        function getLocalMean(integral, width, height, x, y, blockRadius) {
            const x1 = Math.max(0, x - blockRadius);
            const y1 = Math.max(0, y - blockRadius);
            const x2 = Math.min(width - 1, x + blockRadius);
            const y2 = Math.min(height - 1, y + blockRadius);

            const A = (y1 > 0 && x1 > 0) ? integral[(y1 - 1) * width + (x1 - 1)] : 0;
            const B = (y1 > 0) ? integral[(y1 - 1) * width + x2] : 0;
            const C = (x1 > 0) ? integral[y2 * width + (x1 - 1)] : 0;
            const D = integral[y2 * width + x2];

            const sum = D - B - C + A;
            const count = (x2 - x1 + 1) * (y2 - y1 + 1);
            return sum / count;
        }

        function computeAdaptiveBinary(grayData, integral, width, height, blockSize, C) {
            const blockRadius = Math.floor(blockSize / 2);
            const binary = new Uint8Array(width * height);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const localMean = getLocalMean(integral, width, height, x, y, blockRadius);
                    const threshold = localMean - C;
                    binary[idx] = grayData[idx] > threshold ? 255 : 0;
                }
            }
            return binary;
        }

        function findInnerEdge(binary, grayData, width, height, startX, startY, angle) {
            const rad = angle * Math.PI / 180;
            const dx = Math.cos(rad);
            const dy = Math.sin(rad);
            const maxRadius = Math.ceil(Math.hypot(
                Math.max(startX, width - startX),
                Math.max(startY, height - startY)
            ));

            let prevVal = binary[Math.round(startY) * width + Math.round(startX)];

            for (let r = 1; r < maxRadius; r++) {
                const x = Math.round(startX + r * dx);
                const y = Math.round(startY + r * dy);

                if (x < 0 || x >= width || y < 0 || y >= height) break;

                const currVal = binary[y * width + x];

                // Transition from dark (0) to white (255) = inner edge of border
                if (prevVal === 0 && currVal === 255) {
                    return {
                        r_pixels: r,
                        x: startX + r * dx,
                        y: startY + r * dy,
                        value: grayData[y * width + x]
                    };
                }
                prevVal = currVal;
            }
            return null;
        }

        function performAdaptiveDetection(img, angleStart, angleEnd, angleStep, blockSize, thresholdC) {
            const results = [];
            const { startPoint, grayData, width, height } = img;

            const integral = computeIntegralImage(grayData, width, height);
            const binary = computeAdaptiveBinary(grayData, integral, width, height, blockSize, thresholdC);
            img.edgeMap = binary; // Cache for visualization (reuse edgeMap field)

            for (let angle = angleStart; angle <= angleEnd; angle += angleStep) {
                const edgePoint = findInnerEdge(
                    binary, grayData, width, height,
                    startPoint.x, startPoint.y, angle
                );

                if (edgePoint) {
                    results.push({
                        angle_deg: angle,
                        r_pixels: edgePoint.r_pixels,
                        x: edgePoint.x,
                        y: edgePoint.y,
                        value: edgePoint.value
                    });
                }
            }
            return results;
        }

        // ============================================
        // SMOOTHING (MEDIAN FILTER)
        // ============================================

        function smoothContourResults(results, startX, startY, windowSize) {
            if (results.length < windowSize) return results;

            const smoothed = [];
            const halfWindow = Math.floor(windowSize / 2);

            for (let i = 0; i < results.length; i++) {
                const windowVals = [];
                for (let j = -halfWindow; j <= halfWindow; j++) {
                    const idx = Math.max(0, Math.min(results.length - 1, i + j));
                    windowVals.push(results[idx].r_pixels);
                }

                windowVals.sort((a, b) => a - b);
                const medianR = windowVals[Math.floor(windowVals.length / 2)];

                const angle = results[i].angle_deg;
                const rad = angle * Math.PI / 180;

                smoothed.push({
                    angle_deg: angle,
                    r_pixels: medianR,
                    x: startX + medianR * Math.cos(rad),
                    y: startY + medianR * Math.sin(rad),
                    value: results[i].value
                });
            }
            return smoothed;
        }

        // ============================================
        // EDGE OVERLAY VISUALIZATION
        // ============================================

        function drawEdgeOverlay(ctx, edgeMap, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;

            for (let i = 0; i < edgeMap.length; i++) {
                if (edgeMap[i] === 255) {
                    const idx = i * 4;
                    // Green overlay for edges
                    data[idx] = Math.max(0, data[idx] - 50);
                    data[idx + 1] = Math.min(255, data[idx + 1] + 150);
                    data[idx + 2] = Math.max(0, data[idx + 2] - 50);
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function exportToXlsx() {
            const measuredImages = state.images.filter(img => img.results && img.results.length > 0);
            if (measuredImages.length === 0) {
                alert('No measurement data to export.');
                return;
            }

            const workbook = XLSX.utils.book_new();

            // Create summary sheet
            const summaryData = [
                ['Image Name', 'Start X', 'Start Y', 'Points Detected', 'Global Mean']
            ];
            for (const img of measuredImages) {
                summaryData.push([
                    img.name,
                    img.startPoint.x,
                    img.startPoint.y,
                    img.results.length,
                    img.globalMean.toFixed(4)
                ]);
            }
            const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');

            // Create individual sheets for each image
            for (const img of measuredImages) {
                const sheetName = sanitizeSheetName(img.name);
                const data = [
                    ['angle_deg', 'r_pixels', 'x_cart', 'y_cart', 'intensity']
                ];

                for (const r of img.results) {
                    // Convert to cartesian with origin at start point
                    const x_cart = r.r_pixels * Math.cos(r.angle_deg * Math.PI / 180);
                    const y_cart = r.r_pixels * Math.sin(r.angle_deg * Math.PI / 180);

                    data.push([
                        r.angle_deg,
                        r.r_pixels,
                        x_cart.toFixed(4),
                        y_cart.toFixed(4),
                        r.value.toFixed(4)
                    ]);
                }

                const sheet = XLSX.utils.aoa_to_sheet(data);
                XLSX.utils.book_append_sheet(workbook, sheet, sheetName);
            }

            // Create combined data sheet
            const combinedData = [
                ['Image Name', 'angle_deg', 'r_pixels', 'x_cart', 'y_cart', 'intensity']
            ];
            for (const img of measuredImages) {
                for (const r of img.results) {
                    const x_cart = r.r_pixels * Math.cos(r.angle_deg * Math.PI / 180);
                    const y_cart = r.r_pixels * Math.sin(r.angle_deg * Math.PI / 180);
                    combinedData.push([
                        img.name,
                        r.angle_deg,
                        r.r_pixels,
                        x_cart.toFixed(4),
                        y_cart.toFixed(4),
                        r.value.toFixed(4)
                    ]);
                }
            }
            const combinedSheet = XLSX.utils.aoa_to_sheet(combinedData);
            XLSX.utils.book_append_sheet(workbook, combinedSheet, 'All Data');

            // Download
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
            XLSX.writeFile(workbook, `measurement_results_${timestamp}.xlsx`);

            updateStatus('XLSX file exported successfully!');
        }

        async function exportAll() {
            const measuredImages = state.images.filter(img => img.results && img.results.length > 0);
            if (measuredImages.length === 0) {
                alert('No measurement data to export.');
                return;
            }

            updateStatus('Preparing export files...');
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
            const zip = new JSZip();

            // Get current settings
            const detectionMode = document.getElementById('detectionMode').value;
            const enableSmoothing = document.getElementById('enableSmoothing').checked;

            // Build mode-specific settings
            const modeSettings = {};
            if (detectionMode === 'ray') {
                modeSettings.rayThreshold = parseFloat(document.getElementById('rayThreshold').value);
            } else if (detectionMode === 'canny') {
                modeSettings.gaussianSigma = parseFloat(document.getElementById('gaussianSigma').value);
                modeSettings.lowThreshold = parseFloat(document.getElementById('cannyLowThreshold').value);
                modeSettings.highThreshold = parseFloat(document.getElementById('cannyHighThreshold').value);
            } else if (detectionMode === 'adaptive') {
                modeSettings.blockSize = parseInt(document.getElementById('adaptiveBlockSize').value);
                modeSettings.thresholdC = parseFloat(document.getElementById('adaptiveC').value);
            }

            if (enableSmoothing) {
                modeSettings.smoothingWindow = parseInt(document.getElementById('smoothingWindow').value);
            }

            // 1. Create JSON file (Cartesian coordinates only, no polar)
            const jsonData = {
                exportDate: new Date().toISOString(),
                detectionMode: detectionMode,
                settings: {
                    angleStart: parseFloat(document.getElementById('angleStart').value),
                    angleEnd: parseFloat(document.getElementById('angleEnd').value),
                    angleStep: parseFloat(document.getElementById('angleStep').value),
                    smoothingEnabled: enableSmoothing,
                    ...modeSettings
                },
                images: measuredImages.map(img => ({
                    name: img.name,
                    startPoint: { x: img.startPoint.x, y: img.startPoint.y },
                    globalMean: parseFloat(img.globalMean.toFixed(4)),
                    detectionMode: img.detectionMode || detectionMode,
                    measurements: img.results.map(r => {
                        const x_cart = r.r_pixels * Math.cos(r.angle_deg * Math.PI / 180);
                        const y_cart = r.r_pixels * Math.sin(r.angle_deg * Math.PI / 180);
                        return {
                            x: parseFloat(x_cart.toFixed(4)),
                            y: parseFloat(y_cart.toFixed(4)),
                            intensity: parseFloat(r.value.toFixed(4))
                        };
                    })
                }))
            };
            zip.file('measurement_data.json', JSON.stringify(jsonData, null, 2));

            // 2. Create XLSX file
            const workbook = XLSX.utils.book_new();

            // Summary sheet
            const summaryData = [
                ['Image Name', 'Start X', 'Start Y', 'Points Detected', 'Global Mean', 'Detection Mode']
            ];
            for (const img of measuredImages) {
                summaryData.push([
                    img.name,
                    img.startPoint.x,
                    img.startPoint.y,
                    img.results.length,
                    img.globalMean.toFixed(4),
                    img.detectionMode || detectionMode
                ]);
            }
            const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');

            // Individual sheets for each image
            for (const img of measuredImages) {
                const sheetName = sanitizeSheetName(img.name);
                const data = [
                    ['angle_deg', 'r_pixels', 'x_cart', 'y_cart', 'intensity']
                ];

                for (const r of img.results) {
                    const x_cart = r.r_pixels * Math.cos(r.angle_deg * Math.PI / 180);
                    const y_cart = r.r_pixels * Math.sin(r.angle_deg * Math.PI / 180);

                    data.push([
                        r.angle_deg,
                        r.r_pixels,
                        x_cart.toFixed(4),
                        y_cart.toFixed(4),
                        r.value.toFixed(4)
                    ]);
                }

                const sheet = XLSX.utils.aoa_to_sheet(data);
                XLSX.utils.book_append_sheet(workbook, sheet, sheetName);
            }

            // Combined data sheet
            const combinedData = [
                ['Image Name', 'angle_deg', 'r_pixels', 'x_cart', 'y_cart', 'intensity']
            ];
            for (const img of measuredImages) {
                for (const r of img.results) {
                    const x_cart = r.r_pixels * Math.cos(r.angle_deg * Math.PI / 180);
                    const y_cart = r.r_pixels * Math.sin(r.angle_deg * Math.PI / 180);
                    combinedData.push([
                        img.name,
                        r.angle_deg,
                        r.r_pixels,
                        x_cart.toFixed(4),
                        y_cart.toFixed(4),
                        r.value.toFixed(4)
                    ]);
                }
            }
            const combinedSheet = XLSX.utils.aoa_to_sheet(combinedData);
            XLSX.utils.book_append_sheet(workbook, combinedSheet, 'All Data');

            const xlsxData = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
            zip.file('measurement_data.xlsx', xlsxData);

            // 3. Export images with rays
            const imagesFolder = zip.folder('images');
            for (let i = 0; i < state.images.length; i++) {
                const img = state.images[i];
                if (!img.results || img.results.length === 0) continue;

                // Canvas already has the rays drawn, convert to PNG
                const dataUrl = img.canvas.toDataURL('image/png');
                const base64Data = dataUrl.split(',')[1];
                const imageName = img.name.replace(/\.[^/.]+$/, '') + '_with_rays.png';
                imagesFolder.file(imageName, base64Data, { base64: true });
            }

            // Generate and download ZIP
            updateStatus('Generating ZIP file...');
            const zipBlob = await zip.generateAsync({ type: 'blob' });
            const downloadUrl = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = downloadUrl;
            a.download = `measurement_export_${timestamp}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(downloadUrl);

            updateStatus('Export complete! ZIP file downloaded with JSON, XLSX, and images.');
        }

        function sanitizeSheetName(name) {
            // Excel sheet names have limits
            let clean = name.replace(/[\\\/\*\?\[\]:]/g, '_');
            if (clean.length > 28) {
                clean = clean.slice(0, 28);
            }
            return clean;
        }

        function clearAll() {
            if (state.images.length > 0 && !confirm('Clear all images and data?')) {
                return;
            }

            state.images = [];
            state.sourceIndex = null;
            state.measured = false;
            document.getElementById('imageGrid').innerHTML = '';
            updateCounts();
            updateStatus('Cleared. Upload images to begin.');
            updateButtons();
        }

        function updateStatus(text) {
            document.getElementById('statusText').textContent = text;
        }

        function updateCounts() {
            document.getElementById('imageCount').textContent = state.images.length;
            document.getElementById('pointCount').textContent =
                state.images.filter(img => img.startPoint).length;
            document.getElementById('measuredCount').textContent =
                state.images.filter(img => img.results && img.results.length > 0).length;
        }

        function updateButtons() {
            const hasImages = state.images.length > 0;
            const hasSource = state.sourceIndex !== null && state.images[state.sourceIndex]?.startPoint;
            const hasPoints = state.images.some(img => img.startPoint);
            const hasMeasured = state.images.some(img => img.results && img.results.length > 0);

            document.getElementById('propagateBtn').disabled = !hasSource || state.images.length < 2;
            document.getElementById('measureBtn').disabled = !hasPoints;
            document.getElementById('exportBtn').disabled = !hasMeasured;
        }
    </script>
</body>
</html>
